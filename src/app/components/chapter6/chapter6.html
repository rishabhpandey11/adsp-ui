<div class="m-5 overflow-hidden grid gap-5">
    <div class=" text-3xl font-sans font-semibold">
        <h1>Chapter 6 : Introduction to Digital Signal Processing</h1>
    </div>

    <div>
        <mat-card class="example-card text-2xl" appearance="outlined">

            <mat-card-content class="text-lg">
                <h3 class="text-2xl font-semibold font-sans mb-3" style="color: blue;">
                    Learning Objectives
                </h3>


                <ul class="list-disc p-4">
                    <li>Understand what downsampling and upsampling do in time and frequency domain.</li>
                    <li>Predict aliasing and imaging and how to prevent them with filters.</li>
                    <li>Design the correct anti-alias and anti-imaging FIR filters and apply them.</li>
                    <li>Recognize noble identities &amp; when polyphase gives efficiency.</li>
                </ul>
            </mat-card-content>

        </mat-card>
    </div>




    <div>
        <mat-card class="example-card text-2xl" appearance="outlined">

            <mat-card-content class="text-lg gap-4">
                <h3 class="text-2xl font-semibold font-sans mb-3" style="color: blue;">
                    6.1. Sampling the Analog Signal, Normalized Frequency
                </h3>


                <p class="mt-3">


                    Before diving into the mathematics of sampling, let's build an intuitive understanding of what the
                    Fourier transform actually does. Think of it as a "frequency detector" machine.
                </p>
                <p class="mt-3">
                    Fourier transform by
                </p>
                <p class="mt-3 bg-blue-200 ">

                    The key insight is to "wrap" the signal around a circle at different speeds.

                    When the winding frequency matches a frequency present in the signal, the wound-up graph becomes
                    unbalanced; the center of mass shifts away from the origin!
                </p>

                <p class="mt-3">
                    Suppose we are given the sine wave bellow, how would could you recognize that it's oscillating at 3
                    beats per second? What operation could you perform that takes in this graph and spits out the number
                    3?
                </p>
                <div class="flex flex-col justify-around items-center gap-2">
                    <img src="assets/images/chap6/gif6.jpeg" class="w-210 h-70 ">
                </div>
                <p class="mt-4">
                    1. <strong>Wrap the signal around</strong> a circle (in words: multiply the signal by an exponential
                    rotation term written as e^(-j 2œÄ f t), without using math symbols or rendering).
                </p>
                <div class="flex flex-col justify-around items-center gap-2">
                    <img src="assets/images/chap9/fig9.9.png" class="w-180 h-110 ">
                </div>

                <p class="mt-4">
                    2. Vary the winding frequency; how fast we wind around the circle
                </p>

                <div class="flex flex-col justify-around items-center gap-2">
                    <img src="assets/images/chap9/fig9.9.png" class="w-180 h-110 ">
                </div>

                <div class="flex flex-col justify-around items-center gap-2">
                    <img src="assets/images/chap9/fig9.9.png" class="w-180 h-110 ">
                </div>

                <p class="mt-4">3. Track the center of mass of the wound-up graph, mathematically means:
                    <code>g_hat(f) = integral of g(t) multiplied by e^(-j 2*pi*f*t) over all time</code>
                </p>

                <div class="flex flex-col justify-around items-center gap-2">
                    <img src="assets/images/chap9/fig9.9.png" class="w-180 h-110 ">
                </div>


                <div class="flex flex-col justify-around items-center gap-2">
                    <img src="assets/images/chap9/fig9.9.png" class="w-180 h-110 ">
                </div>

                <h1>Sampling the Analog Signal</h1>

                <p class="mt-4">
                    To see what happens when we sample a signal, we start with the analog signal s(t). Sampling means
                    taking values of the signal at intervals T (example: 1/8000 seconds in the ISDN example), or using
                    the sampling frequency f_s (8 kHz in the ISDN example). Mathematically, sampling can be described as
                    multiplying the analog signal with a Dirac impulse located at the sampling times nT, where n is the
                    sample index (n = 0, 1, ... for causal systems).
                </p>

                <div class="flex flex-col justify-around items-center gap-2">
                    <img src="assets/images/chap6/fig6.1.png" class="w-180 h-110 ">
                </div>

                <div class="flex flex-col justify-around items-center gap-2">
                    <img src="assets/images/chap6/fig6.2.png" class="w-180 h-110 ">
                </div>
                <p class="mt-4">
                    The sequence or train of Dirac impulses, as depicted in Fig. (6.2) can be written as:
                </p>
              <p class="text-center mt-3 text-lg font-mono">
                    Œî<sub>T</sub>(t) := ‚àë<sub>n=0</sub><sup>‚àû</sup> Œ¥(t - nT)
                </p>
                <p class="mt-4">
                    Remember that the integral over a Dirac impulse is 1:
                </p>

               <p class="text-center mt-3 text-lg font-mono">
                    ‚à´<sub>t=-‚àû</sub><sup>‚àû</sup> Œ¥(t) dt = 1
                </p>

                <p class="mt-4">
                    The integral over the product of a function with a Dirac impulse is the value of the function at the
                    position of the impulse:
                </p>

               <p class="text-center mt-3 text-lg font-mono">
                    ‚à´<sub>t=-‚àû</sub><sup>‚àû</sup> s(t) Œ¥(t-nT) dt = s(nT)
                </p>


                <p class="mt-4">
                    This is the mathematical formulation of sampling at time-point $nT$. We can now use this description
                    to compute the resulting spectrum with the Fourier transform.

                    First, if the look at the Fourier transform of the analog signal or system, we get
                </p>
              <p class="text-center mt-3 text-lg font-mono">
                    S<sup>c</sup>(œâ) = ‚à´<sub>t=-‚àû</sub><sup>‚àû</sup> s(t) ¬∑ e<sup>-jœât</sup> dt
                </p>
               <p class="mt-4">
                    This is the mathematical formulation of sampling at time-point nT. We can now use this description
                    to compute the resulting spectrum with the Fourier transform.
                </p>

               <p class="mt-4">
                    First, if we look at the Fourier transform of the analog signal or system, we get:
                </p>

              <p class="text-center mt-3 text-lg font-mono">
                    S<sup>c</sup>(œâ) = ‚à´<sub>t=-‚àû</sub><sup>‚àû</sup> s(t) ¬∑ e<sup>-jœât</sup> dt
                </p>

               <p class="mt-4">
                    where the superscript <strong>c</strong> denotes the continuous version, with œâ = 2œÄf the angular
                    frequency. If we now compute the Fourier Transform for the sampled signal s(t) ¬∑ Œî<sub>T</sub>(t),
                    with the replacement:
                </p>

              <p class="text-center mt-3 text-lg font-mono">
                    s(t) ‚Üê s(t) ¬∑ Œî<sub>T</sub>(t)
                </p>

               <p class="mt-4">
                    we obtain the following sum (since only at the sampling time instances the integral is non-zero):
                </p>

             <p class="text-center mt-3 text-lg font-mono">
                    S<sup>d</sup>(œâ) = ‚àë<sub>n=-‚àû</sub><sup>‚àû</sup> s(nT) ¬∑ e<sup>-jœâ nT</sup>
                </p>

               <p class="mt-4">
                    with the superscript <strong>d</strong> now denoting the discrete time version. Now we can see that
                    the frequency variable only appears as œâ nT, and T is the inverse of the sampling frequency.
                </p>

               <p class="mt-4">
                    This is now our normalized frequency. It is without a physical unit, since the unit Hertz in œâ and
                    f<sub>s</sub> cancel. In the normalized frequency, 2œÄ represents the sampling frequency and œÄ is the
                    so-called Nyquist frequency (the upper limit of our usable frequency range, defined as half the
                    sampling frequency). Hence it has the unit of an angle in radians, or radians per sample. The latter
                    assumes that we have a periodic function whose argument is an angle, like e<sup>jŒ©¬∑n</sup>, with n
                    the sample index. Then Œ© is the angle progression per sample.
                </p>

               <p class="mt-4">
                    Observe that we use the capital Œ© to signify that this is the normalized frequency. The capitalized
                    version is commonly used to distinguish it from the continuous, non-normalized version, if both are
                    used. Otherwise, also the small œâ is used in the literature for the normalized frequency, if that is
                    all we need, and there is no danger of confusion.
                </p>

               <p class="mt-4">
                    To convert a normalized frequency back to the non-normalized one, we simply multiply it with the
                    sampling frequency: œâ = Œ© ¬∑ f<sub>s</sub>.
                </p>

               <p class="mt-4">
                    To indicate that we are now in the discrete time domain, we rename our signal to:
                </p>

               <p class="text-center mt-3 text-lg font-mono">
                    x(n) = s(nT)
                </p>

               <p class="mt-4">
                    Its spectrum or frequency response is then:
                </p>

              <p class="text-center mt-3 text-lg font-mono">
                    X(Œ©) = ‚àë<sub>n=-‚àû</sub><sup>‚àû</sup> x(n) e<sup>-jŒ© n</sup>
                </p>

               <p class="mt-4">
                    We call this the ‚ÄúDiscrete Time Fourier Transform‚Äù (DTFT), because we apply it to discrete time
                    signals x(n). This can be distinguished from the Discrete Fourier Transform, because the above time
                    signal has infinite length.
                </p>

               <p class="mt-4">
                    Because n is integer here (no longer real valued like t), we get a 2œÄ periodicity for X(Œ©). This is
                    the first important property for discrete time signals.
                </p>


                <div class="flex flex-col justify-around items-center gap-2">
                    <img src="assets/images/chap6/fig6.3.png" class="w-180 h-110 ">
                </div>
               <p class="mt-4">
                    In Fig. (6.3) we can see that in general we obtain a 2œÄ periodicity in the frequency domain, because
                    of the 2œÄ periodicity of the exponential function exp(jœâ).
                </p>

               <p class="mt-4">
                    Also observe that for real valued signals, the spectrum of the negative frequencies is the complex
                    conjugate of the positive frequencies:
                </p>

              <p class="text-center mt-3 text-lg font-mono">
                    X(-Omega) = X*(Omega)
                </p>

               <p class="mt-4">
                    where * denotes complex conjugation. This is because exp(-j(-Omega)n) = (exp(-j Omega n))*. Since
                    the signal is real-valued, the conjugate does not change it.
                </p>

               <p class="mt-4">
                    This means that for real signals we only need to look at the frequency range from 0 to pi. The
                    negative frequencies are conjugate symmetric and due to 2œÄ periodicity, 0 to pi fully describes the
                    signal. This matches the Nyquist theorem, which says frequencies up to pi (the Nyquist frequency)
                    are sufficient.
                </p>

                <h4>Sampling a Discrete-Time Signal</h4>

               <p class="mt-4">
                    What happens if we downsample an already discrete signal x(n)? Downsampling by N means keeping every
                    Nth sample and discarding the rest. This increases the normalized frequency by a factor of N.
                </p>

               <p class="mt-4">
                    This can also be seen as multiplying the signal by a sequence of unit pulses with zeros in between,
                    and then dropping the zeros. Multiplying by a unit pulse train allows mathematical analysis of
                    downsampling. The resulting frequency response is:
                </p>

              <p class="text-center mt-3 text-lg font-mono">
                    X_down(Omega) = sum over m of x(mN) * exp(-j Omega mN)
                </p>

               <p class="mt-4">
                    Downsampling can be expressed as multiplication with a sampling function:
                </p>

             <p class="text-center mt-3 text-lg font-mono">
                    Delta_N(n) = 1 if n = mN, else 0
                </p>

               <p class="mt-4">
                    The sampled signal with zeros is:
                </p>

              <p class="text-center mt-3 text-lg font-mono">
                    x_down(n) = x(n) * Delta_N(n)
                </p>

               <p class="mt-4">
                    Zeros are removed before transmission or storage to reduce data rate. The decoder upsamples by
                    re-inserting zeros to reconstruct the original sampling rate. This intermediate signal is important
                    in both encoder and decoder analysis.
                </p>

               <p class="mt-4">
                    The spectrum of x_down(n) is the convolution of the original signal's spectrum with the Fourier
                    transform of the unit pulse train. The Fourier transform of the unit pulse train is a Dirac impulse
                    train. Its fundamental angular frequency is 2œÄ/N, since the sampling frequency is reduced by N.
                </p>

               <p class="mt-4">
                    We can represent the Fourier transform of the unit impulse train as:
                </p>

              <p class="text-center mt-3 text-lg font-mono">
                    delta_2pi_N(Omega) = sum from k = 0 to N-1 of (2œÄ/N) * delta(Omega - 2œÄ k / N)
                </p>

               <p class="mt-4">
                    The inverse Discrete-Time Fourier Transform gives:
                </p>

              <p class="text-center mt-3 text-lg font-mono">
                    Delta_N(n) = (1/2œÄ) * integral from 0 to 2œÄ of delta_2pi_N(Omega) * exp(j n Omega) dOmega
                </p>

              <p class="text-center mt-3 text-lg font-mono">
                    = (1/N) * sum from k = 0 to N-1 of exp(j 2œÄ k n / N)
                </p>

               <p class="mt-4">
                    This sum reproduces the original unit pulse train. It is a geometric series and can be verified
                    using standard geometric sum formulas.
                </p>

               <p class="mt-4">
                    Now we have to prove that this is indeed our unit pulse train. To do that, we look at the sum. It is
                    a geometric sum: S = sum from k=0 to N-1 of c^k. Multiplying by c gives S*c = sum from k=1 to N of
                    c^k. Subtracting: S*c - S = c^N - 1. Hence:
                </p>

             <p class="text-center mt-3 text-lg font-mono">
                    S = (c^N - 1) / (c - 1)
                </p>

               <p class="mt-4">
                    Here we set c = exp(j 2œÄ n / N), and the sum can be computed in closed form:
                </p>

             <p class="text-center mt-3 text-lg font-mono">
                    sum from k=0 to N-1 of exp(j 2œÄ k n / N) = (exp(j 2œÄ n) - 1) / (exp(j 2œÄ n / N) - 1)
                </p>

               <p class="mt-4">
                    For n = mN, the sum must become N. In this case, the right-hand side is 0/0, but looking at the
                    left-hand side: exp(j 2œÄ mN k / N) = 1, so the sum becomes N, as desired.
                </p>

               <p class="mt-4">
                    For n not equal to mN, the sum should be zero. Here the denominator is not zero and the numerator
                    becomes zero, so the sum is zero. This proves the formula:
                </p>

              <p class="text-center mt-3 text-lg font-mono">
                    Delta_N(n) = (1/N) * sum from k=0 to N-1 of exp(j 2œÄ k n / N)
                </p>

               <p class="mt-4">
                    We can now use this expression for the unit pulse train to compute the Fourier transform:
                </p>

               <p class="text-center mt-3 text-lg font-mono">
                    x_down(n) = x(n) * Delta_N(n) = x(n) * (1/N) * sum from k=0 to N-1 of exp(j 2œÄ k n / N)
                </p>

               <p class="mt-4">
                    Its Discrete Time Fourier Transform (DTFT) is then:
                </p>

              <p class="text-center mt-3 text-lg font-mono">
                    x_down(Omega) = sum over n from -infinity to infinity of x(n) * (1/N) * sum from k=0 to N-1 of exp(j
                    2œÄ k n / N) * exp(-j Omega n)
                </p>

              <p class="text-center mt-3 text-lg font-mono">
                    = (1/N) * sum from k=0 to N-1 of sum over n of x(n) * exp(-j (-2œÄ k / N + Omega) * n)
                </p>

              <p class="text-center mt-3 text-lg font-mono">
                    = (1/N) * sum from k=0 to N-1 of X(-2œÄ k / N + Omega)
                </p>

               <p class="mt-4">
                    This shows that sampling (still including the zeros) in the frequency domain produces multiple
                    shifted versions of the signal spectrum, called aliasing components:
                </p>

               <p class="text-center mt-3 text-lg font-mono">
                    x_down(Omega) = (1/N) * sum from k=0 to N-1 of X(-2œÄ k / N + Omega)
                </p>

               <p class="mt-4">
                    As seen in Fig. (6.4), the aliasing components periodify the spectrum according to the new sampling
                    rate, which is 1/N of the original sampling rate. The new period is 1/N of the old period (2œÄ).
                </p>

               <p class="mt-4">
                    Observe: Spectral components do not overlap if their bandwidth is below 2œÄ/N for complex signals, or
                    below œÄ/N for real low-pass signals. To reconstruct the original signal, we must ensure aliasing
                    components do not overlap by filtering at the high sampling rate before downsampling. The term
                    "aliasing" can sometimes refer only to overlapping components, or more broadly to any shifted
                    frequency component.
                </p>

               <p class="mt-4">
                    Next, we will show an example including negative frequencies appearing above normalized frequency 1
                    (the Nyquist frequency) and demonstrate two sine signals.
                </p>
                <div class="flex flex-col justify-around items-center gap-2">
                    <img src="assets/images/chap6/fig6.4.png" class="w-180 h-110 ">
                </div>


               <p class="mt-4">
                    At different strength at normalized frequencies 0.4 and 0.35. This can also be seen as a narrow band
                    signal, for example resulting from a passband filter. It is generated with the following code:
                </p>

                <pre class="bg-gray-100 text-sm p-3 rounded-lg overflow-x-auto font-mono">
# Signal Processing Parameters
Fs = 32000
T = 1/Fs
t = np.arange(Fs//32)*T

# Signals
w35 = 0.35*Fs/2
sine_35 = np.sin(2*np.pi*w35*t)
w40 = 0.4*Fs/2
sine_40 = 100*np.sin(2*np.pi*w40*t)
signal = sine_35 + sine_40
</pre>

               <p class="mt-4">
                    Its spectrum can be seen in Fig. (6.5).
                </p>

               <p class="mt-4">
                    After sampling by a factor of N=4, still including the zeros, we get the spectrum shown in Fig.
                    (6.6).
                </p>

               <p class="mt-4">
                    Fig. (6.6) shows that the spectrum still contains the original spectrum, plus the spectral copies at
                    frequency shifts of k * 2 * œÄ / N from the originals.
                </p>

               <p class="mt-4">
                    Observe: Since we have a real-valued signal (the sinusoids), the spectrum of negative and positive
                    frequencies are symmetric around frequency zero. This leads to a mirrored appearance between the
                    neighboring spectral images or aliasing components.
                </p>

               <p class="mt-4">
                    According to Nyquist, we must sample in such a way that the shifted spectra of our signal do not
                    overlap. Otherwise, if they overlap, we cannot separate those parts of the spectrum and lose
                    information, which cannot be reconstructed.
                </p>
                <div class="flex flex-col justify-around items-center gap-2">
                    <img src="assets/images/chap6/fig6.5.png" class="w-180 h-110 ">
                </div>
                <div class="flex flex-col justify-around items-center gap-2">
                    <img src="assets/images/chap6/fig6.6.png" class="w-180 h-110 ">
                </div>
               <p class="mt-4">
                    In conclusion: Sampling a signal by a factor of N, while keeping the zeros between the sample
                    points, leads to N-1 aliasing components or spectral copies.
                </p>

            </mat-card-content>

        </mat-card>
    </div>

    <div>
        <mat-card class="example-card text-2xl" appearance="outlined">


            <mat-card-content class="text-lg">
                <h3>6.1.1 Example</h3>

               <p class="mt-4">
                    Make a sine wave which at 44100 Hz sampling rate has a frequency of 400 Hz and duration of 1 second.
                    Hence we need 44100 samples, and 400 periods of our sinusoid in this second. The signal in Python
                    can be written as:
                </p>

                <pre class="bg-gray-100 text-sm p-3 rounded-lg overflow-x-auto font-mono">
import numpy as np
fs = 44100
f = 400.0
s = np.sin(2 * np.pi * f * np.arange(0,1,1.0/fs))
Omega = 2 * np.pi * f / fs
s1 = np.sin(Omega * np.arange(0, fs, 1))

# Then run it in Python
from sound import sound
sound((2**15) * s, fs)

# Now plot the first 1000 samples:
plot(s[0:1000])
</pre>

               <p class="mt-4">
                    The result can be seen in Fig. (6.7). To listen to it, we use our sound library
                    <a href="http://sound.py/">sound.py</a>, which you can download from our GitHub repository in a
                    terminal with:
                </p>

                <pre class="bg-gray-100 text-sm p-3 rounded-lg overflow-x-auto font-mono">
wget https://raw.githubusercontent.com/TUIlmenauAMS/Python-Audio-Coder/master/
</pre>

               <p class="mt-4">
                    Next, plot the first 100 samples:
                </p>

                <pre class="bg-gray-100 text-sm p-3 rounded-lg overflow-x-auto font-mono">
plot(s[0:100])
</pre>

               <p class="mt-4">
                    The result can be seen in Fig. (6.8). Now we can multiply this sine tone signal with a unit pulse
                    train with N=8. Generate the unit impulse train with:
                </p>
                <div class="flex flex-col justify-around items-center gap-2">
                    <img src="assets/images/chap6/fig6.7.png" class="w-180 h-110 ">
                </div>
                <div class="flex flex-col justify-around items-center gap-2">
                    <img src="assets/images/chap6/fig6.8.png" class="w-180 h-110 ">
                </div>
                <pre class="bg-gray-100 text-sm p-3 rounded-lg overflow-x-auto font-mono">
unit = zeros(44100)
unit[0::8] = 1
plt.stem(unit[0:100], use_line_collection=True)
plt.xlabel('n')
plt.ylabel('unit(n)')
</pre>

               <p class="mt-4">
                    Fig. (6.9) shows the result as a stem plot. Now listen to it, with scaling to the value range for
                    16-bit/sample:
                </p>
                <div class="flex flex-col justify-around items-center gap-2">
                    <img src="assets/images/chap6/fig6.9.png" class="w-180 h-110 ">
                </div>
                <div class="flex flex-col justify-around items-center gap-2">
                    <img src="assets/images/chap6/fig6.10.png" class="w-180 h-110 ">
                </div>
                <pre class="bg-gray-100 text-sm p-3 rounded-lg overflow-x-auto font-mono">
from sound import sound
sound(unit*2.0**15, 44100)
</pre>

               <p class="mt-4">
                    The multiplication with the unit impulse train is:
                </p>

                <pre class="bg-gray-100 text-sm p-3 rounded-lg overflow-x-auto font-mono">
sdu = s * unit
</pre>

               <p class="mt-4">
                    (This multiplication is also called ‚Äúfrequency mixing‚Äù). Now plot the result, the first 100 samples:
                </p>

                <pre class="bg-gray-100 text-sm p-3 rounded-lg overflow-x-auto font-mono">
plot(sdu[0:100])
</pre>

               <p class="mt-4">
                    Now take a look at the magnitude spectrum (in dB) of the original signal s:
                </p>
                <div class="flex flex-col justify-around items-center gap-2">
                    <img src="assets/images/chap6/fig6.11.png" class="w-180 h-110 ">
                </div>
                <div class="flex flex-col justify-around items-center gap-2">
                    <img src="assets/images/chap6/fig6.12.png" class="w-180 h-110 ">
                </div>
                <pre class="bg-gray-100 text-sm p-3 rounded-lg overflow-x-auto font-mono">
from scipy.signal import freqz
w, H = freqz(s)
plot(w, 20 * log10(abs(H) + 1e-3))
xlabel('Normalized Frequency')
ylabel('dB')
title('Magnitude Frequency Response')
</pre>

               <p class="mt-4">Figure 6.11: The magnitude spectrum (in dB) of the original signal s.</p>
               <p class="mt-4">Figure 6.12: The spectrum of the downsampled sinusoid with the zeros still in it, in comparison to
                    the original spectrum.</p>

               <p class="mt-4">
                    Observe that the frequency axis (horizontal) is a normalized frequency, normalized to the Nyquist
                    frequency of 22050 Hz. Hence the 400 Hz sinusoid appears as a peak at normalized frequency 0.05699,
                    which we indeed see.
                </p>

               <p class="mt-4">
                    Compare this to the signal with zeros (sdu), by plotting it on top:
                </p>

                <pre class="bg-gray-100 text-sm p-3 rounded-lg overflow-x-auto font-mono">
w, H = freqz(sdu)
plot(w, 20*log10(abs(H)+1e-3))
legend(('Original Sinusoid','Sampled Sinusoid'))
</pre>
                <div class="flex flex-col justify-around items-center gap-2">
                    <img src="assets/images/chap6/fig6.13.png" class="w-180 h-110 ">
                </div>
               <p class="mt-4">
                    We can see the original 400 Hz tone and the 7 new aliasing components. Always 2 aliasing components
                    are close together because the original 400 Hz tone also has a spectral peak at negative frequencies
                    (-400 Hz, normalized -0.05699).
                </p>

               <p class="mt-4">
                    Listen to the signal with zeros:
                </p>

                <pre class="bg-gray-100 text-sm p-3 rounded-lg overflow-x-auto font-mono">
sound(2**15 * sdu, 44100)
</pre>

               <p class="mt-4">
                    It sounds quite different from the original because of the strong aliasing components!
                </p>

                <h4>Python real-time audio example</h4>
               <p class="mt-4">
                    This example takes microphone input and samples it without removing the zeros, and plays it back in
                    real-time. It constructs a unit pulse train with a 1 at every N‚Äôth sample using the modulus
                    function:
                </p>

                <pre class="bg-gray-100 text-sm p-3 rounded-lg overflow-x-auto font-mono">
s = (np.arange(0, CHUNK) % N) == 0
</pre>

               <p class="mt-4">
                    In Python, True is 1 and False is 0. Start it with:
                </p>

                <pre class="bg-gray-100 text-sm p-3 rounded-lg overflow-x-auto font-mono">
python pyrecplay_samplingblock.py
</pre>

                <h4>Removing the zeros</h4>
               <p class="mt-4">
                    The final step of downsampling is to omit the zeros between samples to obtain the lower sampling
                    rate. Let‚Äôs call the signal without zeros y(m), where the time index m denotes the lower sampling
                    rate (as opposed to n, which denotes the higher sampling rate). In our Python example this is:
                </p>
               <p class="mt-4">
                    We can now take a look at the spectrum with:
                </p>

                <pre class="bg-gray-100 text-sm p-3 rounded-lg overflow-x-auto font-mono">
w, H = freqz(sd)
plot(w, 20*log10(abs(H)+1e-3))
xlabel('Frequency')
ylabel('dB')
title('Magnitude Frequency Response')
</pre>

               <p class="mt-4">
                    Observe in the resulting Fig. (6.14) that the sine signal now appears at a normalized frequency of
                    0.455, a factor of 8 higher than before (with zeros included), because we reduced the sampling rate
                    by 8. This is due to a new Nyquist frequency of 22050/8. The normalized frequency becomes
                    approximately 0.455. Removing the zeros scales or stretches the frequency axis. For this plot, we
                    only have about 12 samples left (100/8 ‚âà 12).
                </p>

               <p class="mt-4">
                    How are the frequency responses or spectra of y(m) and x<sup>d</sup>(n) connected? We can take the
                    Fourier transform of x<sup>d</sup>(n) (still including zeros):
                </p>

                <pre class="bg-gray-100 text-sm p-3 rounded-lg overflow-x-auto font-mono">
X_d(Omega) = sum over n of x_d(n) * exp(-j * Omega * n)
</pre>

               <p class="mt-4">
                    Most of the sum contains zeros. Now we only sum over non-zero entries (every Nth entry), replacing n
                    by m*N:
                </p>

                <pre class="bg-gray-100 text-sm p-3 rounded-lg overflow-x-auto font-mono">
X_d(Omega) = sum over m of x_d(m*N) * exp(-j * Omega * m * N)
</pre>

               <p class="mt-4">
                    Making the substitution y(m) = x_d(m*N), we get:
                </p>

                <pre class="bg-gray-100 text-sm p-3 rounded-lg overflow-x-auto font-mono">
X_d(Omega) = sum over m of y(m) * exp(-j * Omega * N * m) = Y(Omega * N)
</pre>

               <p class="mt-4">
                    This shows that the downsampled version (after removing zeros) has the same frequency response, but
                    the normalized frequency is scaled by the factor N. For example, the normalized frequency pi/N
                    before downsampling becomes pi after removing the zeros. A small part of the spectrum before
                    downsampling becomes the full usable spectrum after downsampling.
                </p>

               <p class="mt-4">
                    We don‚Äôt lose any frequencies this way because the spectrum has multiple copies in increments of
                    2*pi/N, giving it a periodicity of 2*pi/N. Any interval of length 2*pi/N contains a unique part of
                    the spectrum. This is illustrated in Figs. (6.10) to (6.13).
                </p>

               <p class="mt-4">
                    In Fig. (6.17), observe that we shift and add the signal by multiples of pi (2*pi/2). This produces
                    mirrored images of high frequencies at low frequencies (for real-valued signals). The mirrored
                    spectra and original spectrum don‚Äôt overlap, allowing easy reconstruction.
                </p>

                <div class="flex flex-col justify-around items-center gap-2">
                    <img src="assets/images/chap6/fig6.14.png" class="w-180 h-110 ">
                </div>

               <p class="mt-4">
                    Figure 6.17: Signal spectrum after multiplication with the unit pulse train, for N=2, setting every
                    second value to zero (zeros still included in the sequence).
                </p>


            </mat-card-content>

        </mat-card>


    </div>



    <div>
        <mat-card class="example-card text-2xl" appearance="outlined">

            <mat-card-content class="text-lg">
                <h3 class="text-2xl font-semibold font-sans mb-3" style="color: blue;">
                    6.2 Upsampling </h3>



               <p class="mt-4">
                    What is still missing in our system is the upsampling, which is the opposite operation of
                    downsampling, for cases where we want to increase the sampling rate.
                </p>

               <p class="mt-4">
                    One common (but incorrect) approach to upsampling by a factor of N is to simply repeat each sample
                    N-1 times. This is equivalent to first inserting N-1 zeros after each sample, and then filtering the
                    resulting sequence with a low-pass filter whose impulse response is N ones. This is a very special
                    case.
                </p>

               <p class="mt-4">
                    In general, we upsample by first inserting N-1 zeros after each sample, and then applying an
                    interpolation filter (low-pass, high-pass, or band-pass as needed) to reconstruct the signal. This
                    process helps to select the correct spectral copy of the original signal.
                </p>

               <p class="mt-4">
                    We take the signal at the lower sampling rate as y(m), where m is the index at the lower sampling
                    rate. The upsampled signal, including the inserted zeros, is x<sup>d</sup>(n), where n is the index
                    at the higher sampling rate. This is simply the reverse of the final step in downsampling.
                </p>

               <p class="mt-4">
                    From downsampling, we have the relation:
                </p>

              <p class="text-center mt-3 text-lg font-mono">
                    X<sup>d</sup>(Omega) = Y(Omega * N)
                </p>

               <p class="mt-4">
                    Or equivalently:
                </p>

              <p class="text-center mt-3 text-lg font-mono">
                    X<sup>d</sup>(Omega / N) = Y(Omega)
                </p>

               <p class="mt-4">
                    Here we are going from y(m) to the upsampled signal x<sup>d</sup>(n). For example, if a frequency
                    component was at pi before upsampling, it becomes pi / 2 for the upsampled signal when N=2. This
                    effectively extends the frequency range.
                </p>

               <p class="mt-4">
                    Since the upsampled signal x<sup>d</sup>(n) includes zeros, its spectrum is again periodic in
                    frequency, similar to the downsampling case. The periodicity remains because the original signal was
                    2*pi periodic, and after upsampling, the frequency scale adjusts accordingly.
                </p>



            </mat-card-content>

        </mat-card>


    </div>


    <div>
        <mat-card class="example-card text-2xl" appearance="outlined">

            <mat-card-content class="text-lg">
                <h3 class="text-2xl font-semibold font-sans mb-3" style="color: blue;">
                    6.3 Reconstruction </h3>



               <p class="mt-4">
                    Observe that if the aliasing components do not overlap, we can perfectly reconstruct the signal
                    using a suitable filter. To prevent overlap, we filter the signal at the higher sampling rate before
                    aliasing occurs (as in the high-pass example). If overlap already exists at the lower sampling rate,
                    the different components cannot be separated and the signal is effectively "destroyed".
                </p>

               <p class="mt-4">
                    We can perfectly reconstruct the high-pass signal in our example using ideal filters, with
                    upsampling and ideal high-pass filtering.
                </p>

               <p class="mt-4">
                    This gives the analysis and synthesis diagram shown in Figure 6.19.
                </p>

                <div class="flex flex-col justify-around items-center gap-2">
                    <img src="assets/images/chap6/fig6.15.png" class="w-180 h-110 ">
                </div>
               <p class="mt-4">Figure 6.18: Signal spectrum after downsampling (removing the zeros) by N (2 in this example).
                    Observe the stretching of the spectrum by a factor of 2.</p>

                <div class="flex flex-col justify-around items-center gap-2">
                    <img src="assets/images/chap6/fig6.16.png" class="w-180 h-110 ">
                </div>
               <p class="mt-4">Figure 6.19: Downsampling (analysis) and upsampling (synthesis).</p>

               <p class="mt-4">
                    Observe that we violate the conventional Nyquist criterion, because our high-pass filter passes high
                    frequencies. However, sampling mirrors these frequencies to the lower range, allowing the
                    traditional Nyquist theorem to be applied. This approach is known as bandpass Nyquist and is
                    important in filter banks and wavelets. It states that we can perfectly reconstruct a bandpass
                    signal if we sample at twice the rate of the bandwidth of the signal, assuming ideal filters to
                    avoid spectral overlap of aliasing components.
                </p>

               <p class="mt-4">
                    In general, this holds for complex filters. For real-valued filters, this assumption works only if
                    the bandpass filters start at frequencies of (pi / N) * k, where k is an integer. Otherwise, overlap
                    with aliased components may occur, as illustrated in Figure 6.20.
                </p>
                <div class="flex flex-col justify-around items-center gap-2">
                    <img src="assets/images/chap6/fig6.17.png" class="w-180 h-110 ">
                </div>

            </mat-card-content>

        </mat-card>


    </div>







    <div>
        <mat-card class="example-card text-2xl" appearance="outlined">

            <mat-card-content class="text-lg">
                <h3 class="text-2xl font-semibold font-sans mb-3" style="color: blue;">
                    6.3.1 Example
                </h3>



               <p class="mt-4">
                    We have a real-valued bandpass filter which starts its passband at a small frequency epsilon and
                    ends at epsilon + (pi / N). Since the filter is real-valued, the passband also appears at the
                    corresponding negative frequencies, from -epsilon to -(epsilon + pi / N). After multiplying with the
                    unit pulse train, we get one (out of N) aliasing component by shifting the negative passband by 2pi
                    / N to the positive frequencies. This results in the range from (pi / N - epsilon) to (2pi / N -
                    epsilon). Hence, there is an overlap in this range, and we could not perfectly reconstruct our
                    signal.
                </p>

               <p class="mt-4">
                    Therefore, sampling at twice the bandwidth for real-valued signals and filters only works if the
                    band limits are aligned with multiples of (pi / N) * k. To avoid overlapping aliasing components, we
                    can either increase the sampling rate (for example, to twice the usual rate, or 4 times the
                    bandwidth) to provide a "safety margin", or shift the bandpass signals in frequency so that they
                    align with the grid.
                </p>

               <p class="mt-4">
                    This restriction is not necessary for complex signals or filter banks. Complex filter banks are
                    used, for instance, in acoustic echo cancellation, where the sampling rate can be increased by a
                    fraction (less than a factor of 2) to reduce aliasing artifacts while keeping lower complexity.
                </p>

               <p class="mt-4"><strong>Summary:</strong> If our band boundaries are aligned with multiples of pi / N, we can
                    downsample by N. Otherwise, for real-valued signals, it is safer to downsample by N/2. For complex,
                    one-sided signals (e.g., only positive frequencies), we can always downsample by N, regardless of
                    the bandpass placement.
                </p>

               <p class="mt-4">
                    Compare this with the standard Nyquist case: here we have a lowpass signal which we downsample and
                    reconstruct, as shown in Figure 6.21.
                </p>

                <div class="flex flex-col justify-around items-center gap-2">
                    <img src="assets/images/chap6/fig6.18.png" class="w-180 h-110 ">
                </div>

            </mat-card-content>

        </mat-card>


    </div>


    <div>
        <mat-card class="example-card text-2xl" appearance="outlined">

            <mat-card-content class="text-lg">
                <h3 class="text-2xl font-semibold font-sans mb-3" style="color: blue;">
                    6.3.2 Python Example
                </h3>



               <p class="mt-4">
                    This program can be controlled by keyboard and features sampling by a factor of N = 8 (keeping the
                    zeros). It also includes a low-pass filter before and after sampling to suppress the aliasing
                    components. Both sampling and filtering can be turned on and off. The program displays the magnitude
                    of the resulting DFT spectrum after reconstruction (after the last low-pass filter) in a waterfall
                    spectrogram:
                </p>

                <ul>
                    <li>The magnitude of the DFT is displayed as color (yellow is high, blue is low).</li>
                    <li>The horizontal axis is frequency (0 to Nyquist frequency).</li>
                    <li>The vertical axis is time (up is past).</li>
                </ul>

               <p class="mt-4">Start it with:</p>
                <pre><code>python pyrecspecwaterfallsampling.py</code></pre>

               <p class="mt-4"><strong>Observe:</strong> When sampling is turned on, aliasing artifacts are clearly audible, and
                    they also appear as spectral copies in the waterfall spectrogram.</p>

               <p class="mt-4">When the low-pass filter is turned on, most aliasing artifacts are no longer audible, and most of
                    them disappear from the waterfall spectrogram. However, the sound also becomes more muffled.</p>



            </mat-card-content>

        </mat-card>


    </div>
    <div class="h-6"></div>

    <!-- Test section  -->





</div>



<div class="flex flex-col items-center p-3 gap-6">
    <h2 class="text-2xl font-sans font-semibold mb-4">üß† Test Your Knowledge</h2>

    <div *ngFor="let q of questions" class="w-full md:w-2/3">
        <mat-card class="mat-elevation-z6 p-6 font-sans">
            <mat-card-title>{{ q.text }}</mat-card-title>
            <br>
            <mat-card-content>
                <mat-radio-group [(ngModel)]="q.selectedAnswer" [disabled]="q.isSubmitted">
                    <div *ngFor="let option of q.options" class="mb-2">
                        <mat-radio-button [value]="option">{{ option }}</mat-radio-button>
                    </div>
                </mat-radio-group>

                <div class="mt-4 flex gap-3">
                    <button matFab extended (click)="submitAnswer(q)" [disabled]="!q.selectedAnswer || q.isSubmitted">
                        Submit
                    </button>

                    <button matFab extended style="background-color:black ; color: aliceblue;" *ngIf="q.isSubmitted"
                        (click)="tryAgain(q)">
                        Try Again
                    </button>
                </div>

                <div class="mt-4">
                    <p *ngIf="q.isSubmitted && q.selectedAnswer === q.correctAnswer"
                        class="text-green-600 font-semibold font-sans">
                        ‚úÖ Correct!
                    </p>
                    <p *ngIf="q.isSubmitted && q.selectedAnswer !== q.correctAnswer"
                        class="text-red-600 font-semibold font-sans">
                        ‚ùå Incorrect. Correct answer: <strong>{{ q.correctAnswer }}</strong>.
                    </p>
                </div>
            </mat-card-content>
        </mat-card>
    </div>
</div>