<div class="m-5 overflow-hidden space-y-4">
    <div class=" text-3xl font-sans font-semibold">
        <h1>Chapter 9 : Allpass Filters, Warping</h1>
    </div>
   
    <div>
        <mat-card class="example-card text-2xl" appearance="outlined">

            <mat-card-content class="text-lg">



                <p class="mt-4">
                    This book presents the algorithms with Python examples, and the mathematics behind them, of advanced
                    This chapter helps students understand how allpass filters maintain a constant magnitude response
                    while shaping the phase. Learners will explore how these filters create fractional delays and how
                    their phase response can warp the frequency axis. The chapter also introduces frequency-warping
                    techniques and shows how replacing FIR delays with allpass sections affects filter behavior.
                    Students will finally understand how warping relates to perceptual scales such as the Bark scale.
                </p>
            </mat-card-content>

        </mat-card>
    </div>

   


    <div>
        <mat-card class="example-card text-2xl" appearance="outlined">

            <mat-card-content class="text-lg gap-4">


                <h3 class="text-2xl font-semibold font-sans " style="color: blue;">
                    1. Theory
                </h3>

                <h3 class="text-xl font-semibold font-sans mt-3">
                    1.1 Allpass Filters
                </h3>


                <p class="mt-3">
                    So far we specified the magnitude of our frequency response and didn‚Äôt care much about
                    the phase. For allpass filters, it is basically the other way around.
                    In the beginning of filter design, we saw that we can write a transfer function as
                </p>
                <p class="text-center mt-3 text-lg font-mono">
                    H(e
                    j‚Ñ¶
                    ) = e
                    jœï(‚Ñ¶)
                    ¬∑ A(e
                    j‚Ñ¶
                    )
                </p>

                <p class="mt-3">
                    Here we specify, or rather, alter the phase, and keep the the magnitude of our frequency
                    response at constant 1, meaning
                </p>
                <p class="text-center mt-3 text-lg font-mono">


                    A(e
                    j‚Ñ¶
                    ) = 1
                </p>
                <p class="mt-3">
                    Hence we would like to have a filter with transfer function H of magnitude constant 1,
                </p>
                <p class="text-center mt-3 text-lg font-mono">


                    H(e
                    j‚Ñ¶
                    )

                    = 1
                </p>
                <p class="mt-3">
                    This also means: The magnitude of our z-transform is 1 on the unit circle in complex
                    z-plane
                </p>
            </mat-card-content>

        </mat-card>
    </div>
   
    <div>
        <mat-card class="example-card text-2xl" appearance="outlined">


            <mat-card-content class="text-lg">
                <h3 class="text-xl font-semibold font-sans ">
                    1.2 Allpass Filter as Fractional Delay </h3>

                <p class="mt-3">
                    We can use such a filter to implement a ‚Äúfractional‚Äù delay d, where d is a real number,
                    for instance d = 0.5 if we want to delay a signal by half a sample. In this case we cannot
                    simply use a memory element as in the case of integer delays. In lecture 8 we saw that in
                    this case, our ideal frequency response in the Discrete Time Fourier Transform (DTFT)
                    domain is
                </p>




                <p class="text-center mt-3 text-lg font-mono">
                    H(e
                    j‚Ñ¶
                    ) = e
                    ‚àíj‚Ñ¶¬∑d
                </p>

                <p class="mt-3">
                    To obtain its ideal impulse response for a filter design, we apply the inverse DTFT, also as seen in
                    lecture 8,
                </p>

                <p class="text-center mt-3 text-lg font-mono">
                    h(n) = (1 / (2*pi)) * integral from -pi to pi of H(e^(j*Omega)) * e^(j*Omega*n) dOmega
                </p>

                <p class="text-center mt-3 text-lg font-mono">
                    h(n) = (1 / (2*pi)) * integral from -pi to pi of e^(-j*Omega*d) * e^(j*Omega*n) dOmega
                </p>

                <p class="text-center mt-3 text-lg font-mono">
                    h(n) = (1 / (2*pi)) * integral from -pi to pi of e^(j*Omega*(n - d)) dOmega
                </p>

                <p class="text-center mt-3 text-lg font-mono">
                    (1 / (2*pi)) * [ (1 / (j*(n - d))) * e^(j*pi*(n - d)) - (1 / (j*(n - d))) * e^(-j*pi*(n - d)) ] =
                </p>

                <p class="text-center mt-3 text-lg font-mono">
                    Using e^(j*x) - e^(-j*x) = 2*j*sin(x) we obtain:
                </p>

                <p class="text-center mt-3 text-lg font-mono">
                    (1 / (2*pi*j*(n - d))) * 2*j * sin(pi*(n - d)) =
                </p>

                <p class="text-center mt-3 text-lg font-mono">
                    (1 / (pi*(n - d))) * sin(pi*(n - d))
                </p>

                <p class="text-center mt-3 text-lg font-mono">
                    sinc(n - d)
                </p>

                <p class="mt-3">
                    This means our ideal impulse response is simply a sinc function, shifted by d! For the case of an
                    integer delay d this degenerates to a 1 at the d-th position of our impulse response, and zeros
                    elsewhere. But for non-integer d we get an infinitely long filter. To make this an FIR filter, we
                    need to apply a "window function", as described in the lecture "Multirate Signal Processing".
                </p>









            </mat-card-content>

        </mat-card>


    </div>
  


   
    <div>
        <mat-card class="example-card text-2xl" appearance="outlined">

            <mat-card-content class="text-lg">
                <h3 class="text-xl font-semibold font-sans mb-3">
                    1.2.1 Example </h3>

                <p class="mt-3">
                    The window function is a sine window:
                </p>

                <p class="text-center mt-3 text-lg font-mono">
                    w(n) = sin(pi * L * (n + 0.5)), with n = 0 .. L - 1, and L:
                </p>

                <p class="mt-3">
                    length of the window. This avoids having sudden ends of the impulse response. We also want to keep
                    the most significant parts of our sinc function to keep the resulting error small. The samples we
                    drop should be small. To include some of the significant values of the sinc function at negative n,
                    we need to shift it to positive indices (by n0) to make it causal. In this way, we obtain our
                    impulse response,
                </p>

                <p class="text-center mt-3 text-lg font-mono">
                    h(n) = sinc(-d + n - n0) * w(n)
                </p>

                <p class="mt-3">
                    This n0 is then an additional delay. We could give it the integer part of our desired delay, and the
                    fractional part would be the "d" for the sinc filter.
                </p>



            </mat-card-content>

        </mat-card>


    </div>
   

    <div>
        <mat-card class="example-card text-2xl" appearance="outlined">

            <mat-card-content class="text-lg">


                <h3 class="text-xl font-semibold ">1.2.2 Python example</h3>

                <p class="text-lg mt-3">
                    (when copy and paste from the pdf file: replace the quotation marks by typed ones)
                    Take L = 10, n0 = 4
                </p>

                <pre class="bg-gray-100 text-sm p-3 rounded-lg overflow-x-auto font-mono mt-2">

ipython -pylab
#time index range:
L=10
n=arange(L)
n
#Out: array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])

w=sin(pi/L*(n+0.5))
plot(w)
title(‚ÄôThe Sine Window‚Äô)
plot(sinc(-0.5+n-4))
title(‚ÄôThe Shifted Sinc Function‚Äô)
h=w*sinc(-0.5+n-4)
plot(h)
legend((‚ÄôSine Window‚Äô, ‚ÄôSinc Function‚Äô, ‚ÄôWindowed Sinc Function‚Äô))
title(‚ÄôThe Shifted Windowed Sinc Function‚Äô)
figure()
x=np.hstack((arange(4),zeros(8)))
plot(x)

import scipy.signal as sp
y=sp.lfilter(h,1,x)
plot(y)
legend((‚ÄôOriginal Signal‚Äô,‚ÄôShifted signal, by 4.5 samples‚Äô))
title(‚ÄôThe Test Signal, Shifted by our Filter by 4.5 Samples‚Äô)
#Test with longer filter, to reduce errors:
figure()
L=20
n=arange(L)
w=sin(pi/L*(n+0.5))
plot(sinc(-0.5+n-9))
h=w*sinc(-0.5+n-9)
plot(h)
legend((‚ÄôThe Shifted Sinc Function‚Äô,‚ÄôThe Shifted Windowed Sinc Function‚Äô))
figure()
x=np.hstack((arange(4),zeros(12)))
y=sp.lfilter(h,1,x)
plot(x)
plot(y)
legend((‚ÄôOriginal Signal‚Äô, ‚ÄôShifted signal, by 9.5 samples‚Äô))
title(‚ÄôThe Test Signal, Shifted by our Filter by 9.5 Samples‚Äô)   


</pre>

                <p class="text-lg mt-3">
                    The resulting output can be seen in Fig.(9.1) and (9.2) and (9.3) and fig. (9.4).
                    Observe: The longer we make the filter impulse response, keeping the main lobe of
                    the sinc function in the center, the smaller the resulting error for the shifted signal x
                    becomes, but the hight of the ripples remains similar. We can obtain its frequency
                    response with our freqz function, which can be seen in Fig. (9.5).
                </p>

                <pre class="bg-gray-100 text-sm p-3 rounded-lg overflow-x-auto font-mono mt-2">

import freqz
freqz.freqz(h,1)...

</pre>
                <p class="text-lg mt-3">
                    Looking at Fig. (9.5), remember that phase angle= -d Omega, for a delay d, hence
                    d= -Angle/Omega, the negative slope. Also observe that the magnitude is mostly at 0
                    dB, as it should be for an allpass filter, but at high frequencies at about above about
                    normalized frequency 2.8 it deviates from it. So in that sense it is only approximately
                    an allpass filter.
                </p>



                <p class="text-lg mt-2">
                    To estimate the obtained delay (for verification), we use the mouse, go to y=-3.14,
                    which is the first wrap around point, and read out position x=0.32. From that we obtain
                    the delay d= -y/x = 3.14/0.32=9.8, which is indeed roughly the desired 9.5 samples
                    delay. Keep in mind that our calculation from the plot is only a rough estimation.
                    This gives us a tool for fractional delays! But we have this attenuation at high high
                    frequencies. IIR filters can improve our filters performance.
                </p>





            </mat-card-content>

        </mat-card>


    </div>
   

    <div class="flex flex-col justify-around items-center gap-2">
        <img src="assets/images/chap9/fig9.1.png" class="w-180 h-110 ">

        <h1 class="text-wrap">

        </h1>
    </div>

   


    <div>
        <mat-card class="example-card text-2xl" appearance="outlined">

            <mat-card-content class="text-lg">
                <h3 class="text-2xl font-semibold font-sans" style="color: blue;">
                    1.2.3 IIR Fractional Delay Allpass Filter Design
                </h3>

                <p class="mt-4">
                    In [23] a way to design IIR fractional delay allpass filters is described. As a Python
                    function it is,
                </p>

                <pre class="bg-gray-100 text-sm p-3 rounded-lg overflow-x-auto font-mono mt-2">

def allp_delayfilt(tau):
‚Äô‚Äô‚Äô
produces a Fractional-delay All-pass Filter
Arguments: tau: fractional delay in samples (float).
:returns:
a: Denominator of the transfer function
b: Numerator of the transfer function

L = int(tau)+1
n = np.arange(0,L)
a_0 = np.array([1.0])
a = np.array(np.cumprod( np.divide(np.multiply((L -
n), (L-n-tau)) , (np.multiply((n+1), (n+1+tau))))))
a = np.append(a_0, a) # Denominator of the transfer function
b = np.flipud(a) # Numerator of the transfer function
return a, b


</pre>

                <div class="flex flex-col justify-around items-center gap-2">
                    <img src="assets/images/chap9/fig9.2.png" class="w-180 h-110 ">

                    <h1 class="text-wrap">

                    </h1>
                </div>

                <p class="mt-4">
                    We put it in a python file with name ‚Äúallp_delayfilt.py‚Äù, in which we also have a main
                    section to test it,
                </p>

                <pre class="bg-gray-100 text-sm p-3 rounded-lg overflow-x-auto font-mono mt-2">

if __name__ == ‚Äô__main__‚Äô:
#testing the fractional delay allpass filter
import matplotlib.pyplot as plt
import scipy.signal as sp
#fractional delay of 5.5 samples:
a,b=allp_delayfilt(5.5)

print("a=",a,"b=",b)
x=np.hstack((np.arange(4),np.zeros(8)))
y=sp.lfilter(b,a,x) #applying the allpass filter
plt.plot(x)
plt.plot(y)
plt.xlabel(‚ÄôSample‚Äô)
plt.title(‚ÄôThe IIR Fractional Delay Filter Result‚Äô)
plt.legend((‚ÄôOriginal Signal‚Äô, ‚ÄôDelayed Signal‚Äô))
plt.show()


</pre>



                <p class="mt-4">
                    We execute it in a terminal shell with,

                </p>

                <p class="bg-gray-100 text-sm p-3 rounded-lg overflow-x-auto font-mono mt-2">
                    python3 allp_delayfilt.py
                </p>
                <p class="mt-4">
                    and get the plot of our test signal ( a ramp function) and its delayed version, delayed by
                    5.5 samples using the IIR filter. The resulting plot can be seen in Fig. 9.7 . Observe that
                    the extrapolated zero crossing of the orange delayed signal would indeed be at around
                    5.5 samples. Also observe that particularly before our signal we now have fewer ripples.
                    The frequency response of the IIR fractional delay allpass filter is displayed with our
                    ‚Äúfreqz‚Äù function as seen in Fig. 9.7. Observe that the magnitude is practically precisely
                </p>
                <div class="flex flex-col justify-around items-center gap-2">
                    <img src="assets/images/chap9/fig9.3.png" class="w-180 h-110 ">

                    <h1 class="text-wrap">

                    </h1>
                </div>




                <p class="mt-4">
                    at 0 dB, except for rounding errors, meaning a gain factor of 1, and no attenuation
                    at high frequencies anymore. This makes it indeed an allpass filter. Also observe the
                    phase plot at normalized frequency, put the mouse over Omega=0.5. The angle is -2.8
                    radiants. Remember: Angle= -d ‚Ñ¶, for a delay d, hence d= -Angle/‚Ñ¶ = 2.8/0.5 = 5.6.
                    This fits nicely to our desired delay of 5.5 samples! This application is described more
                    detailed e.g. in: [24].


                <p class="mt-4">

                    Since an IIR filter does not have a linear phase anymore, the group delay can change
                    with frequency. To check its variation it is helpful to plot the group delay over normalized
                    frequency. Python Scipy has the function "group_delay" to compute the group delay,
                    given the IIR filter coefficients as arguments, as in the following code,
                </p>
                <pre class="bg-gray-100 text-sm p-3 rounded-lg overflow-x-auto font-mono mt-2">

w,gd=sp.group_delay((b,a))
plt.plot(w,gd)
plt.xlabel(‚ÄôNormalized freuency‚Äô)
plt.ylabel(‚ÄôGroup delay‚Äô)
plt.title(‚ÄôGroup delay of our IIR fractional delay filter for 5.5 samples delay‚Äô)


</pre>

                <p class="mt-4">
                    The resulting plot can be seen in Fig (9.8). We can see that the desired fractional delay
                    of 5.5 sample is indeed obtained up to about normalized frequency 1.5, but then increases
                    continuously. So this is now a different trade-off. Instead of the increasing magnitude
                </p>
                <div class="flex flex-col justify-around items-center gap-2">
                    <img src="assets/images/chap9/fig9.5.png" class="w-180 h-110 ">

                    <h1 class="text-wrap">

                    </h1>
                </div>



                <p class="mt-4">
                    attenuation at high frequencies for the FIR fractional delay filter, here we have instead
                    an increasing group delay towards higher frequencies. What is more desirable depends
                    on the application.

                </p>
                <p class="mt-4">

                    Application example: Stereo source separation, with 2 sources and 2 microphones.
                    We want to cancel one of the 2 sources, and for that we need to model the precise delay
                    from one microphone to the other to be able to remove the signal by subtraction. See
                    e.g.: [25], [26]
                </p>
            </mat-card-content>

        </mat-card>




    </div>
   


    <div>
        <mat-card class="example-card text-2xl" appearance="outlined">

            <mat-card-content class="text-lg">
                <h3 class="text-xl font-semibold font-sans ">
                    1.2.4 Generic Simple IIR Allpass Filters
                </h3>

                <p class="mt-4">


                    The simplest allpass filter has one pole and one zero in the z-domain for the transfer
                    function,
                </p>
                <p class="text-center mt-3 text-lg font-mono">
                    H_ap(z) = (z^-1 - conj(a)) / (1 - a z^-1) = (-conj(a) * (1 - z^-1 / a)) / (1 - a z^-1)
                </p>

                <p class="mt-4">
                    where a is a complex number, and a¬Ø specifies the conjugate complex number.
                    Observe that here we have a zero at z =1 / a
                    and a pole at z = a! The pole and the zero
                    are at conjugate reverse locations! Example: If a=0.5, we obtain the pole/zero plot
                    with Python,
                </p>
                <div class="flex flex-col justify-around items-center gap-2">
                    <img src="assets/images/chap9/fig9.6.png" class="w-180 h-110 ">

                    <h1 class="text-wrap">

                    </h1>
                </div>

                <pre class="bg-gray-100 text-sm p-3 rounded-lg overflow-x-auto font-mono mt-2">

a=0.5; #Pole location
B=[1/a.conjugate()]; #the zero location
A=[a];
from zplane import zplane
zplane(B,A,[-1.1, 2.1, -1.1, 1.1]); #plot the pole/zero diagram
#with axis limits...


</pre>
                <p class="mt-4">
                    The resulting plot can be seen in Fig. 9.9. In this plot, the cross at 0.5 is the pole,
                    and the circle at 2 is the zero.

                    How can we see that the magnitude of the frequency response H(ejŒ©) is 1?
                    We can re-write it as:
                </p>
                <p class="text-center mt-3 text-lg font-mono">
                    H_ap(e^(j*Omega)) = (e^(-j*Œ©) - conj(a)) / (1 - a e^(-j*Œ©)) = e^(-j*Œ©) * (1 - conj(a)
                    e^(j*Œ©)) / (1 - a e^(-j*Œ©))
                </p>

                <p class="mt-4">
                    Here you can see that the expression in the numerator is the conjugate complex of the
                    denominator, hence their magnitude cancels to one. The exponential before the fraction
                    also has magnitude 1, hence the entire expression has magnitude 1,
                </p>
                <p class="mt-4">
                    |H_ap(e^(j*Omega))| = 1
                </p>
                <p class="mt-4">
                    Here we can see, using just 1 pole and one zero, we can obtain a magnitude of constant
                </p>
                <div class="flex flex-col justify-around items-center gap-2">
                    <img src="assets/images/chap9/fig9.7.png" class="w-180 h-110 ">

                    <h1 class="text-wrap">

                    </h1>
                </div>

                <p class="mt-4">
                    We could obtain more complex allpass filter by using a product of this simple transfer
                    function, perhaps with different coefficients.
                    More interesting now is the resulting phase. The phase function can be found in [22]:
                </p>
                <p class="text-center mt-3 text-lg font-mono">
                    phi(Omega) = -Omega - 2 * arctan( (r * sin(Omega - theta)) / (1 - r * cos(Omega - theta)) )
                </p>

                <p class="mt-4">
                    Where r is the magnitude of a and Œ∏ is the phase angle of a (so a = r ¬∑ e^(jŒ∏)). Observe that the
                    phase expression is highly non-linear because of the trigonometric functions. For example, one could
                    use curve fitting with Œ∏ and r to obtain a desired fractional delay in some frequency range.
                </p>

                <p class="mt-4">
                    We can now plot the resulting phase over the normalized frequency and compare it with the phase of a
                    delay of 1 sample (corresponding to z^-1 in the z-domain), which has phase œÜ(Œ©) = ‚àíŒ©. This is shown
                    in the plot of Fig. 9.10 for a = 0.5 and a = ‚àí0.5. The blue curve corresponds to the all-pass phase
                    for a = 0.5, the green curve for a = ‚àí0.5, and the red curve is for a = 0, representing the phase of
                    a pure 1-sample delay z^-1.
                </p>

                <p class="mt-4">
                    It can be seen that the beginning and end of the curves (frequencies 0 and œÄ) are identical, and
                    only in between does the all-pass phase deviate from the 1-sample delay. For a = 0, the all-pass
                    filter becomes exactly z^-1, a delay of one sample, so its behavior is very close to an ordinary
                    delay.
                </p>

                <p class="mt-4">
                    Such an IIR all-pass filter can also be used to implement fractional delays. In the plot, observe
                    the different slopes (derivatives) of the phase with respect to frequency.
                </p>



                <div class="flex flex-col justify-around items-center gap-2">
                    <img src="assets/images/chap9/fig9.8.png" class="w-180 h-110 ">

                    <h1 class="text-wrap">

                    </h1>
                </div>
                <p class="mt-4">
                    to frequency, which shows different group delays for different coefficients a. For instance
                    the green curve for a=-0.5 at frequencies below about half Nyquist frequency has a slope
                    which is about a third of the slope of the red curve for a delay of 1 sample, and hence
                    represents a fractional delay.
                    Observe that an IIR filter always has a non-symmetric impulse reponse, since it starts
                    at time 0 and continues to infinity. This means IIR filters always have non-linear phase!
                </p>

            </mat-card-content>

        </mat-card>


    </div>
   

    <div>
        <mat-card class="example-card text-2xl" appearance="outlined">

            <mat-card-content class="text-lg">



                <h3 class="text-2xl font-semibold mt-4">1.2.5 Frequency Warping</h3>
                <p class="mt-4 mb-3">

                    In Fig. (9.10) for a=0.5 (the blue curve) we observe a ‚Äústretching‚Äù of the low frequency
                    range, where a small part of the low frequencies stretch over a wider phase range than
                    the other curves. For the frequency warping we will interpret the negative phase as a
                    normalized frequency. The plot was produced with a simple Python function for the
                    phase function,
                </p>



                <pre>
ipython -pylab
import numpy as np

def warpingphase(w, a):
    # produces (outputs) phase wy for an allpass filter
    # w: input vector of normalized frequencies (0..pi)
</pre>
                <pre><code>
#a: allpass coefficient  
#phase of allpass zero/pole :  
theta = np.angle(a);  
#magnitude of allpass zero/pole :  
r = np.abs(a);  

wy = -w - 2*np.arctan((r*np.sin(w - theta)) / (1 - r*np.cos(w - theta)));  

return wy  

w = np.arange(0, 3.14, 0.01)  

plot(w, warpingphase(w, 0.5))  
plot(w, warpingphase(w, 0))  
plot(w, warpingphase(w, -0.5))  
</code></pre>

                <div class="flex flex-col justify-around items-center gap-2">
                    <img src="assets/images/chap9/fig9.9.png" class="w-180 h-110 ">

                    <h1 class="text-wrap">

                    </h1>
                </div>

                <p class="mt-4">
                    The phase at the output of our phase function can also be interpreted as a normalized frequency.
                </p>

                <p class="mt-4">
                    An important observation: the <code>warpingphase</code> function with coefficient
                    <code>-conj(a)</code> is the inverse of the <code>warpingphase</code> function with coefficient
                    <code>a</code>!
                    We can test this in Python:
                </p>

                <pre><code>

import matplotlib.pyplot as plt

</code></pre>
                <div class="flex flex-col justify-around items-center gap-2">
                    <img src="assets/images/chap9/fig9.10.png" class="w-180 h-110 ">

                    <h1 class="text-wrap">

                    </h1>
                </div>
                <pre><code>

from warpingphase import *
# frequency range:
w = np.arange(0, np.pi, 0.01)
a = 0.5 * (1+1j)
wyy = warpingphase(warpingphase(w, a), -a.conjugate())
plt.plot(w, wyy)
plt.xlabel('Normalized Frequency')
plt.ylabel('Phase Angle')

</code></pre>

                <p class="mt-4">
                    The resulting plot can be seen in Fig. (9.11). Here we see that it is indeed the identity
                    function. This shows that interpreting the allpass as a normalized frequency "warper",
                    the allpass with coefficient a is inverse to the allpass with -a.
                </p>

                <p class="mt-4">
                    What is the frequency response of an example allpass filter? For a given parameter,
                    for example a = 0.5, we can use freqz (instead of eq. 9.1). There we expect to see the
                    magnitude remain constant at 1, and the phase angle behave as predicted by our phase formula.
                    This also allows cross-checking the results.
                </p>

                <p class="mt-4">
                    Using the z-transform of the transfer function:
                </p>

                <p class="text-center mt-3 text-lg font-mono">
                    H_ap(z) = (z^-1 - conjugate(a)) / (1 - a * z^-1)
                </p>


                <div class="flex flex-col justify-around items-center gap-2">
                    <img src="assets/images/chap9/fig9.11.png" class="w-180 h-110 ">

                    <h1 class="text-wrap">

                    </h1>
                </div>

                <p class="mt-4">We set our coefficient vectors to:</p>

                <pre><code>
                    
a = 0.5
B = [-a.conjugate(), 1]
A = [1, -a]

</code></pre>

                <p class="mt-4">
                    Observe that for freqz the higher exponents of z^-1 appear to the right in "A" and "B".
                </p>

                <p class="mt-4">Now plot the frequency response and impulse response:</p>

                <pre><code>
                    
from freqz import freqz
freqz(B, A)

</code></pre>

                <p class="mt-4">
                    The resulting plot can be seen in Fig. (9.13). Here we can see in the magnitude plot
                    that we obtain a constant value of 1 (0 dB; the small value around 2e-15 comes from
                    finite accuracy and rounding errors). The lower plot shows the non-linear phase, matching
                    the earlier phase plots.
                </p>

                <p class="mt-4">To obtain the impulse response, we use the function "lfilter" and input a unit impulse:
                </p>

                <pre><code>

from scipy import signal as sp
Imp = np.zeros(21)

</code></pre>

                <div class="flex flex-col justify-around items-center gap-2">
                    <img src="assets/images/chap9/fig9.12.png" class="w-180 h-110 ">

                    <h1 class="text-wrap">

                    </h1>
                </div>


                <p class="mt-4">
                    We set the first element of the impulse and compute the impulse response:
                </p>

                <pre><code>
    
Imp[0] = 1  # an impulse, a 1 followed by 20 zeros
h = sp.lfilter(B, A, Imp)
plot(h)
title('Impulse Response of our IIR Allpass with a=0.5')
xlabel('Sample')
ylabel('Value')


</code></pre>

                <p class="mt-4">
                    We obtain the impulse response plot of Fig. (9.13). Here we can see that the first,
                    non-delayed sample is not zero, but -0.5. This can also be seen by printing the first
                    four elements of the impulse response:
                </p>

                <pre><code>

print(h[0:4])
ans = [-0.5, 0.75, 0.375, 0.1875]

</code></pre>

                <p class="mt-4">
                    The second element corresponds to the delay of 1 sample (the z^-1 term), with a factor
                    of 0.75. But then there are more samples, going back into the past, exponentially
                    decaying. This means not only past samples go into the filtering calculation, but also
                    more distant past samples, and even the non-delayed sample with a factor of -0.5.
                </p>

                <p class="mt-4">
                    This is a problem for frequency warping (next section) if we want to use frequency
                    warping inside IIR filters, because this would create delay-less loops, which are difficult
                    to implement. With FIR filters this is not a problem.
                </p>

                <div class="flex flex-col justify-around items-center gap-2">
                    <img src="assets/images/chap9/fig9.13.png" class="w-180 h-110 ">

                    <h1 class="text-wrap">

                    </h1>
                </div>

            </mat-card-content>

        </mat-card>
    </div>

   
    <div>
        <mat-card class="example-card text-2xl" appearance="outlined">

            <mat-card-content class="text-lg">
                <h3 class="text-xl font-semibold font-sans ">
                    1.2.6 Frequency Warping Approximating the Bark Scale
                </h3>


                <p class="mt-4">
                    These properties of the allpass can now be used to warp the frequency scale of a filter
                    (by effectively replacing ejŒ© with e^(œÜ(Œ©)) in the frequency response), for example to map
                    it according to the Bark scale used in psycho-acoustics.
                </p>

                <p class="mt-4">
                    A common approximation of the Bark scale (from Wikipedia, based on Zwicker and Terhard)
                    uses the frequency f in Hz. The Bark scale approximates the changing frequency resolution
                    of the inner ear's cochlea. Because of the structure of the cochlea, the ear has different
                    sensitivities for different frequencies and different signals. The signal-dependent threshold
                    of audibility is called the Masking Threshold. It has more spectral detail at lower frequencies
                    than at higher frequencies, according to the Bark scale.
                </p>

                <p class="mt-4">
                    We can plot the Bark formula using the Python program, resulting in Fig. (9.14):
                </p>

                <pre><code>ipython --pylab

# Frequency array between 0 and 20000 Hz in 1000 steps:
f = linspace(0, 20000, 1000)

# Computation of Zwicker's Bark approximation formula:
z = 13 * arctan(0.00076 * f) + 3.5 * arctan((f / 7500.0) ** 2)

# Plot Bark over Hertz:
plot(f, z)
xlabel('Frequency in Hertz')
ylabel('Frequency in Bark')
title('Zwicker & Terhard Approximation')
</code></pre>
                <div class="flex flex-col justify-around items-center gap-2">
                    <img src="assets/images/chap9/fig9.14.png" class="w-180 h-110 ">

                    <h1 class="text-wrap">

                    </h1>
                </div>
                <p class="mt-4">
                    Observe the similarity of this curve to the negative phase plot of the allpass filter for a = 0.5.
                </p>

                <p class="mt-4">
                    Here we see that 1 Bark at lower frequency has a much smaller bandwidth than at higher frequencies.
                    This means the ear has a higher frequency resolution at lower frequencies than at higher
                    frequencies.
                    Imagine we want to design a filter or system for hearing purposes. For instance, we might want to
                    model the masking threshold of the ear for any given signal using some linear filter (FIR or IIR).
                    Then it would be useful to give this filter a higher frequency resolution at lower frequencies,
                    so it matches the smaller details of the masking threshold in that region.
                </p>

                <p class="mt-4">
                    But typical design methods distribute filter details independently of the frequency range.
                    For example, the Remez method produces equally distributed ripples. Here we can use frequency
                    warping so that the low-frequency range is enlarged and the high-frequency range is compressed.
                    This makes the filter operate on the warped frequency scale, so it sees lower frequencies in more
                    detail,
                    because they are spread out more compared to higher frequencies.
                </p>

                <p class="mt-4">
                    How do we do this? For some frequency response H(e^(j*Omega)), we want to warp the frequency Omega
                    with some function phi(Omega) according to our desired frequency scale, so the new response becomes:
                </p>

                <p class="text-center mt-3 text-lg font-mono">
                    H( e^(j * phi(Omega)) )
                </p>

                <p class="mt-4">
                    This is exactly the principle of an allpass filter, which has the frequency response:
                </p>

                <p class="text-center mt-3 text-lg font-mono">
                    H_ap(e^(j*Omega)) = e^(j * phi_ap(Omega))
                </p>

                <p class="mt-4">
                    Usually we want to map positive frequencies to positive frequencies again. Since phi_ap(Omega)
                    for the allpass filter becomes negative, we use the approach of replacing z in the argument of
                    our transfer function with the reverse allpass transfer function.
                </p>


                <p class="text-center mt-3 text-lg font-mono">
                    Replace: z^-1 ‚Üê H_ap(a, z)
                </p>

                <p class="mt-4">
                    This means every delay element in the filter is now warped by the allpass filter. In this way,
                    the linear function on the unit circle in the z-plane is replaced by the nonlinear, warped
                    function of the allpass filter. The warped transfer function therefore becomes:
                </p>

                <p class="text-center mt-3 text-lg font-mono">
                    H_warped(z) = H( 1 / H_ap(a, z) )
                </p>

                <p class="text-center mt-3 text-lg font-mono">
                    The resulting frequency response becomes:
                </p>

                <p class="text-center mt-3 text-lg font-mono">
                    H_warped(e^(j*Omega)) = H( e^(-j * phi_ap(Omega)) )
                </p>

                <p class="mt-4">
                    Here we can see that the desired frequency warping has been achieved.
                </p>

                <p class="mt-4">
                    What does this mean for the filter implementation? We know that FIR filters always consist
                    of many delay elements z^-1. For example, consider an FIR filter:
                </p>

                <p class="text-center mt-3 text-lg font-mono">
                    H(z) = sum from m = 0 to L of b(m) * z^(-m)
                </p>

                <p class="mt-4">
                    The warped version of this filter becomes:
                </p>

                <p class="text-center mt-3 text-lg font-mono">
                    H( 1 / H_ap(a, z) ) = sum from m = 0 to L of b(m) * ( H_ap(a, z) )^m
                </p>

                <p class="mt-4">
                    To obtain a desired filter, we now first have to warp our desired filter, and then design
                    our filter in the warped domain.
                    Observe that the warping turns an FIR filter into an IIR filter, because the allpass
                    has poles outside of zero.
                    An example of this kind of design can be seen in Fig. (9.15), from [27]. Here we can
                    see that the 12th order filter successfully approximated the more detailed curve at low

                    frequencies, using the warping approach. Another application, using warping for low
                    delay audio coding, is described in [28].
                </p>
                <div class="flex flex-col justify-around items-center gap-2">
                    <img src="assets/images/chap9/fig9.15.png" class="w-200 h-140 ">

                    <h1 class="text-wrap">

                    </h1>
                </div>

            </mat-card-content>

        </mat-card>
    </div>

   
    <div>
        <mat-card class="example-card text-2xl" appearance="outlined">

            <mat-card-content class="text-lg">
                <h3 class="text-2xl font-semibold font-sans " style="color: blue;">
                    1.2.7 Frequency Warping, Filter Design Example
                </h3>


                <p class="mt-4">
                    We want to design a warped low-pass filter with a cutoff frequency of 0.05 * pi
                    (pi is the Nyquist frequency). This cutoff is the end of the passband. Frequency
                    warping will be used to obtain a warping similar to the Bark scale of human hearing.
                </p>

                <p class="mt-4">
                    As a comparison, we first design an unwarped filter with 4 coefficients (4 taps)
                    using the same specifications. The function scipy.signal.remez uses a normalized
                    frequency scale where 0.5 corresponds to the Nyquist frequency. Therefore, our cutoff
                    frequency of 0.05 * pi (about 0.157) becomes 0.025.
                </p>

                <pre class="bg-gray-100 text-sm p-3 rounded-lg overflow-x-auto font-mono mt-2">
ipython -pylab
from freqz import freqz
import scipy.signal as sp

# remez uses normalized sampling frequency = 1
cunw = sp.remez(4, [0, 0.025, 0.025 + 0.025, 0.5], [1, 0], [1, 100])
print(cunw)

# Impulse response:
plot(cunw)
xlabel('Sample')
ylabel('value')
title('Unwarped Filter Coefficients')

# Frequency response:
freqz(cunw, 1)
</pre>

                <p class="mt-4">
                    The resulting coefficients appear in Fig. (9.16) and the frequency response in Fig. (9.17).
                    The frequency response shows that this is not a good filter. The passband is too wide
                    (up to normalized frequency about 0.4), and there is almost no stopband attenuation
                    (from about 0.5 to pi). This makes it unsuitable for our application.
                </p>

                <p class="mt-4">
                    Next we design a 4th-order FIR low-pass filter that will be frequency-warped later.
                    First we compute the allpass coefficient ‚Äúa‚Äù that gives an approximation to Bark-scale
                    warping. According to equation (26) in reference [27], we compute:
                </p>

                <div class="flex flex-col justify-around items-center gap-2">
                    <img src="assets/images/chap9/fig9.16.png" class="w-180 h-110 ">

                   
                </div>

                <pre class="bg-gray-100 text-sm p-3 rounded-lg overflow-x-auto font-mono mt-2">
from warpingphase import *

# Allpass coefficient for Bark-like warping:
a = 1.0674 * (2 / np.pi * np.arctan(0.6583 * 32))**0.5 - 0.1916
# Result: a = 0.85956 for sampling rate 32 kHz

# Warped cutoff frequency:
fcw = -warpingphase(0.05 * np.pi, 0.85956)
# fcw = 1.6120 in radians

# Cutoff normalized to 2*pi for remez:
fcny = fcw / (2 * np.pi)
# fcny = 0.25656

# Filter coefficients in the warped domain:
c = sp.remez(4, [0, fcny, fcny + 0.1, 0.5], [1, 0], [1, 100])

# Plot impulse response:
plt.plot(c)
xlabel('Sample')
ylabel('value')
title('Filter Coefficients in Warped Domain')

# Plot frequency response:
freqz(c, 1)
</pre>

<div class="flex flex-col justify-around items-center gap-2">
                    <img src="assets/images/chap9/fig9.17.png" class="w-180 h-110 ">

                    <h1 class="text-wrap">

                    </h1>
                </div>

                <p class="mt-4">
                    The coefficients appear in Fig. (9.18) and the corresponding frequency response in Fig. (9.19).
                    This is the filter obtained from the coefficients c if we do not replace the delays
                    with allpass filters. In the warped domain this produces a reasonable low-pass filter.
                    The passband (from 0 to slightly above 1.6 radians) drops only about 10 dB, and the
                    stopband attenuation reaches about 30 dB, much better than the unwarped case.
                </p>

                <p class="mt-4">
                    Now we take the same coefficient vector c, but replace the delay elements in the FIR
                    filter with allpass filters. This means we transform the filter from:
                </p>
                <p class="text-center mt-3 text-lg font-mono">
                    H(z) ‚Üí H_warped(z) = H( 1 / H_ap(a, z) )
                </p>
                <pre class="bg-gray-100 text-sm p-3 rounded-lg overflow-x-auto font-mono mt-2">

# Warping Allpass filters:
#Numerrator:
B = [-a.conjugate(), 1]
#Denominator:
A = [1, -a]
# Impulse with 80 zeros:
Imp = np.zeros(80)
Imp[0] = 1
x = Imp;

# Y1(z)=A(z), Y2(z)=A^2(z),...
# Warped delays:
y1 = sp.lfilter(B,A,x)
y2 = sp.lfilter(B,A,y1)
y3 = sp.lfilter(B,A,y2)
# Output of warped filter with impulse as input:
yout = c[0]*x+c[1]*y1+c[2]*y2+c[3]*y3
# frequency response:
freqz(yout, 1);

</pre>

<div class="flex flex-col justify-around items-center gap-2">
                    <img src="assets/images/chap9/fig9.18.png" class="w-180 h-110 ">

                    <h1 class="text-wrap">

                    </h1>
                </div>


                <p class="mt-4">
                    Here we can now see the frequency response of our final warped low pass filter. We
                    can see that again we have a drop of about 10 dB in the passband, now from 0 to 0.05pi,
                    and a stopband attenuation of about 30dB, which is somewhat reasonable.
                </p>
               <pre class="bg-gray-100 text-sm p-3 rounded-lg overflow-x-auto font-mono mt-2">

#Impulse response:
plot(yout);
xlabel(‚ÄôSample‚Äô)
ylabel(‚Äôvalue‚Äô)
title(‚ÄôImpulse Response of Warped Lowpass Filter‚Äô)

</pre>

<div class="flex flex-col justify-around items-center gap-2">
                    <img src="assets/images/chap9/fig9.19.png" class="w-180 h-110 ">

                    <h1 class="text-wrap">

                    </h1>
                </div>
                <p class="mt-4">
                    This is the resulting impulse response of our warped filter. What is most obvious is
                    its length. Instead of just 4 samples, as our original unwarped design, it easily reaches
                    80 significant samples, and in principle is infinite in extend. This is also what makes it
                    a much better filter than the unwarped original design!
                </p>

             

                
            </mat-card-content>

        </mat-card>
    </div>
<div class="flex flex-col justify-around items-center gap-2">
                    <img src="assets/images/chap9/fig9.20.png" class="w-180 h-110 ">

                    <h1 class="text-wrap">

                    </h1>
                </div>

                <div class="flex flex-col justify-around items-center gap-2">
                    <img src="assets/images/chap9/fig9.21.png" class="w-180 h-110 ">

                    <h1 class="text-wrap">

                    </h1>
                </div>

                <div class="flex flex-col justify-around items-center gap-2">
                    <img src="assets/images/chap9/fig9.22.png" class="w-180 h-110 ">

                    <h1 class="text-wrap">

                    </h1>
                </div>

    <!-- Test section  -->





</div>



<div class="flex flex-col items-center p-3 gap-6">
    <h2 class="text-2xl font-sans font-semibold mt-4">üß† Test Your Knowledge</h2>

    <div *ngFor="let q of questions" class="w-full md:w-2/3">
        <mat-card class="mat-elevation-z6 p-6 font-sans">
            <mat-card-title>{{ q.text }}</mat-card-title>
            <br>
            <mat-card-content>
                <mat-radio-group [(ngModel)]="q.selectedAnswer" [disabled]="q.isSubmitted">
                    <div *ngFor="let option of q.options" class="mb-2">
                        <mat-radio-button [value]="option">{{ option }}</mat-radio-button>
                    </div>
                </mat-radio-group>

                <div class="mt-4 flex gap-3">
                    <button matFab extended (click)="submitAnswer(q)" [disabled]="!q.selectedAnswer || q.isSubmitted">
                        Submit
                    </button>

                    <button matFab extended style="background-color:black ; color: aliceblue;" *ngIf="q.isSubmitted"
                        (click)="tryAgain(q)">
                        Try Again
                    </button>
                </div>

                <div class="mt-4">
                    <p *ngIf="q.isSubmitted && q.selectedAnswer === q.correctAnswer"
                        class="text-green-600 font-semibold font-sans">
                        ‚úÖ Correct!
                    </p>
                    <p *ngIf="q.isSubmitted && q.selectedAnswer !== q.correctAnswer"
                        class="text-red-600 font-semibold font-sans">
                        ‚ùå Incorrect. Correct answer: <strong>{{ q.correctAnswer }}</strong>.
                    </p>
                </div>
            </mat-card-content>
        </mat-card>
    </div>
</div>