<div class="m-5  overflow-hidden space-y-4">
    <div class=" text-3xl font-sans font-semibold">
        <h1>Chapter 2 : Quantization Signal to Noise Ratio (SNR)</h1>
    </div>


    <div>
        <mat-card class="example-card text-2xl" appearance="outlined" style="background-color: #FFF5E4;">
            <mat-card-header>
                <mat-card-title style="color: blue;">1. Learning Objectives</mat-card-title>
            </mat-card-header>
            <br>
            <mat-card-content class="text-lg">
                <p class="text-lg font-semibold mb-2">
                    After completing this module, learners will be able to:
                </p>

                <ul class="list-disc ml-6 text-lg">
                    <li>
                        Explain the purpose of <strong>quantization</strong> in digital signal processing.
                    </li>

                    <li>
                        Describe the difference between <strong>mid-tread</strong> and <strong>mid-rise</strong>
                        quantizers.
                    </li>

                    <li>
                        Compute the quantization step size using the formula:
                        <span class="font-mono">Œî = (Vmax ‚àí Vmin) / L</span>
                    </li>

                    <li>
                        Understand and visualize the <strong>quantization error</strong> and how it depends on bit
                        depth.
                    </li>

                    <li>
                        Relate quantization to the A/D conversion chain used in acoustic systems.
                    </li>
                </ul>


            </mat-card-content>

        </mat-card>


    </div>





    <div>
        <mat-card class="example-card text-2xl" appearance="outlined">

            <mat-card-content class="text-lg">
                <h3 class="text-2xl font-semibold font-sans mb-3" style="color: blue;">
                    2.1 Introduction
                </h3>


                <p class="mt-4">
                    Assume we have an A/D converter with a quantizer with a certain number of bits
                    (say N bits). What is the resulting Signal to Noise Ratio (SNR) of this quantizer?
                    The SNR is defined as the ratio of the expectation of the signal power to the expectation
                    of the noise power. In our case, the expectation of the noise power is the expectation of the
                    quantization error power. We already have the expectation of the quantization error power as
                    (Delta^2) / 12 [6].
                </p>


                <p class="mt-4">
                    So what we still need for the SNR is the average or expectation of the signal power.
                    How do we obtain this? Basically, we can take the same approach as we did for the expectation
                    of the power of the quantization error (which is basically the second moment of the distribution
                    of the quantization error) [7]. So what we need to know from our signal is its probability
                    distribution. For the quantization error, it was a uniform distribution between ‚àíDelta/2 and
                    +Delta/2.
                </p>

                <p class="mt-4">
                    A very simple case would be a uniformly distributed signal with amplitude A/2
                    which has values between ‚àíA/2 up to +A/2.
                </p>
                <p appMathJax="$$E[x^2] = \int_{-\frac{A}{2}}^{\frac{A}{2}} x^{2} \cdot p(x) dx \tag{2.1}$$"></p>


                <p class="mt-4">
                    So here we have the same type of signal and the resulting expectation of the power (its second
                    moment assumed we have a zero mean signal) is obtained by using our previous formula and replace
                    $\Delta$ by $A$. The resulting power is:
                </p>
                <p appMathJax="$$ \frac{A^2}{12} \tag{2.2} $$"></p>






                <p class="mt-4">
                    Which signals have this property? One example is uniformly distributed random values (basically like
                    our quantization error). Python numpy produces this kind of signal if we use the command:
                    numpy.random.rand() - 0.5 (the 0.5 is to make the distribution centered around 0) [8].
                </p>


            </mat-card-content>

        </mat-card>
    </div>




    <div class="flex flex-col justify-around items-center gap-2">
        <img src="assets/images/chap2/quantization.png" class="w-200 h-80 ">
        <h1 class="text-wrap">
            Block diagram of a Pulse Code Modulation (PCM) encoder illustrating the steps of analog-to-digital
            conversion: the continuous analog signal is first sampled to form a Pulse Amplitude Modulated (PAM) signal,
            then quantized into discrete amplitude levels, and finally encoded into a binary digital data stream.

        </h1>
    </div>


    <div class="flex flex-col justify-around items-center gap-2">
        <img src="assets/images/chap2/fig2.1.1.gif" class="w-200 h-80 ">
        <h1 class="text-wrap">
            Figure 2.2: full-scale sinusoid is quantized with increasing bit-depth B. As B grows, the staircase
            distortion becomes finer and the quantized signal converges to the original waveform, while the
            signal-to-quantization-noise ratio (SNR) increases by roughly 6¬†dB per additional bit.
        </h1>
    </div>





    <div>
        <mat-card class="example-card text-2xl" appearance="outlined">

            <mat-card-content class="text-lg">
                <h3 class="text-2xl font-semibold font-sans mb-3" style="color: blue;">
                    2.2 Examples of Uniform PDFs
                </h3>
                <h3 class="text-xl font-semibold font-sans mb-3">
                    2.2.1 Triangular Wave
                </h3>
                <p class="text-lg mt-3">
                    An example of a uniform probability density function (pdf) is a triangular wave (see Figure 2.1).
                    How do we obtain its pdf?
                </p>

                <p class="text-lg mt-3">
                    One can imagine the vertical axis (the function value) divided into small intervals, and each
                    interval is passed in the same amount of time. Because every amplitude value occurs for the same
                    duration, the resulting pdf is <strong>uniform</strong>.
                </p>
            </mat-card-content>

        </mat-card>


    </div>
    <div class="flex flex-col justify-around items-center gap-2">
        <img src="assets/images/chap2/fig2.1.2.png" class="w-200 h-100 ">
        <h1 class="text-wrap">
            Figure 2.2: Triangular wave with uniform pdf
        </h1>
    </div>




    <div>
        <mat-card class="example-card text-2xl" appearance="outlined">

            <mat-card-content class="text-lg">



                <h3 class="text-xl font-semibold mt-4">2.2.2 Sawtooth Wave</h3>

                <p class="text-lg mt-3">
                    A further example is a sawtooth wave (see Figure 2.2). Again, we can make the same argument:
                    each small interval of the function value is covered in the same amount of time. Therefore,
                    the resulting probability density function (pdf) is uniform.
                </p>

                <p class="text-lg mt-3">
                    We have now seen several examples that satisfy the assumption of a uniform distribution
                    (realistic examples), and we know that their expected power is A¬≤ / 12.
                </p>

            </mat-card-content>

        </mat-card>
    </div>




    <div class="flex flex-col justify-around items-center gap-2">
        <img src="assets/images/chap2/fig2.2.png" class="w-200 h-100 ">
        <h1 class="text-wrap">
            Figure 2.2: Sawtooth wave with uniform pdf
        </h1>
    </div>

    <div>
        <mat-card class="example-card text-2xl" appearance="outlined">

            <mat-card-content class="text-lg">
                <h3 class="text-2xl font-semibold font-sans " style="color: rgb(22, 22, 22);">
                    2.3 Calculating the SNR
                </h3>


                <p class="mt-4">
                    So what does this then mean for the SNR? The SNR is just the ratio:
                </p>

                <p class="text-lg font-mono mt-3 text-center" appMathJax="$$ SNR = \frac{A^2/12}{\Delta^2/12} = \frac{A^2}{\Delta^2} \tag{2.3}

 $$">
                </p>

                <p>
                    If we assume our signal is full range, meaning the maximum values of our A/D converter are
                    &minus;A&#8260;2 and +A&#8260;2 (the signal goes to the maximum), we can compute the step size
                    &Delta; if we know the number of bits of the converter and if we assume uniform quantization
                    step sizes.
                </p>

                <p>
                    Assume we have <strong>N</strong> bits in our converter. This means we have
                    <strong>2<sup>N</sup></strong> quantization intervals.
                </p>

                <p>
                    We obtain the step size <strong>&Delta;</strong> by dividing the full range by this number:
                </p>



                <p class="text-lg font-mono mt-3 text-center" appMathJax="$$ \Delta = \frac{A}{2^N} \tag{2.4}

 $$">
                </p>

                <p>
                    Plug this in the SNR equation and we obtain:
                </p>

                <p class="text-lg font-mono mt-3 text-center" appMathJax="$$ SNR = \frac{A^2}{\Delta^2} = \frac{A^2}{(\frac{A}{2^N})^2} = 2^{2N} \tag{2.5}
 $$">
                </p>
                <p>
                    This is now quite a simple result! But usually, the SNR is given in dB (decibels), so let‚Äôs convert
                    it into dB:
                </p>


                <p class="text-lg font-mono mt-3 text-center" appMathJax="$$ SNR_{dB} = 10 \cdot \log_{10}(2^{2N}) = 10 \cdot 2N \cdot \log_{10}(2) \approx 6.02N \text{ dB} \tag{2.6}
 $$">
                </p>

                <p>
                    This is now our famous rule of thumb that each bit more gives you about 6 dB more SNR. But observe
                    that
                    the above formula only holds for uniformly distributed full-range signals!
                    (The signal is between &minus;A&#8260;2 and +A&#8260;2 using all possible values of our converter.)
                </p>

            </mat-card-content>

        </mat-card>
    </div>




    <div>
        <mat-card class="example-card text-2xl" appearance="outlined">

            <mat-card-content class="text-lg">


                <h2 class="text-2xl font-semibold mt-6">2.4 Non-full Range Signals</h2>

                <p class="text-lg mt-3">
                    What happens if the signal is not full range? What is the SNR if we have a signal with
                    reduced range? Assume our signal has an amplitude of A / c with a factor c > 1.
                </p>

                <p class="text-lg mt-3">
                    We can plug this into our equation:
                </p>
                <p class="text-lg font-mono mt-3 text-center" appMathJax="$$ 

SNR = \frac{(A/c)^2}{\Delta^2} = \frac{(A/c)^2}{(A/2^N)^2} = 2^{2N} / c^2 \tag{2.7} $$"></p>

                <p class="text-lg font-mono mt-3 text-center"
                    appMathJax="$$ 

SNR_{dB} = 10 \cdot \log_{10}(2^{2N}/c^2) = 10 \cdot 2N \cdot \log_{10}(2) - 20 \cdot \log_{10}(c) \approx 6.02N \text{ dB} - 20 \cdot \log_{10}(c) \tag{2.8} $$">
                </p>



                <p class="text-lg mt-3">
                    The term 20 ¬∑ log10(c) is the number of decibels by which we are below full range.
                    This means the SNR is reduced by exactly that amount.
                </p>


                <h3 class="text-xl font-semibold mt-6">2.4.1 Example</h3>

                <p class="text-lg mt-3">
                    For a 16-bit quantizer, the SNR for a full-range uniform signal is:
                </p>
                <p class="text-lg font-mono mt-3 text-center" appMathJax="$$  SNR = 6.02 \cdot 16 \text{ dB} = 96.32 \text{ dB} \tag{2.9} 

 $$">
                </p>



                <p class="text-lg mt-3">
                    Now assume the same signal is 20 dB below full range (i.e., only one-tenth of the
                    full range). The resulting SNR is:
                </p>

                <p class="text-lg font-mono mt-2 text-center">
                    96.32 dB ‚àí 20 dB = 76.32 dB
                </p>

                <p class="text-lg mt-3">
                    This is much lower. It shows why it is important not to leave too much headroom:
                    a sound engineer should keep the signal as high as possible without reaching full
                    range to avoid clipping.
                </p>


            </mat-card-content>

        </mat-card>
    </div>





    <div>
        <mat-card class="example-card text-2xl" appearance="outlined">

            <mat-card-content class="text-lg">

                <h2 class="text-2xl font-semibold mt-6">2.5 Non-uniformly Distributed Signals</h2>

                <p class="text-lg mt-3">
                    The other assumption we made concerned the type of signal we quantize. What if we do not
                    have a uniformly distributed signal? As we saw, speech and audio signals are best modeled
                    by a Laplacian distribution or a Gaussian mixture model, and similar models apply for
                    audio signals in general.
                </p>

                <p class="text-lg mt-3">
                    Even a simple sine wave does not fulfill the assumption of a uniform distribution.
                    What is the pdf of a simple sine wave? (see Figure 2.3).
                </p>

                <p class="text-lg mt-3">
                    Observe: If a sinusoid represents a full-range signal, its values lie between
                    ‚àíA/2 and +A/2, just like in the previous examples.
                </p>



            </mat-card-content>

        </mat-card>
    </div>



    <div class="flex flex-col justify-around items-center gap-2">
        <img src="assets/images/chap2/fig2.3.png" class="w-200 h-100 ">
        <h1 class="text-wrap">
            Figure 2.3: Sine wave with a non-uniform PDF
        </h1>
    </div>



    <div>
        <mat-card class="example-card text-2xl" appearance="outlined">

            <mat-card-content class="text-lg">

                <h2 class="text-2xl font-semibold mt-6">2.6 Conclusion</h2>

                <p class="text-lg mt-3">
                    In summary, the SNR for a quantizer can be easily calculated using the derived formulas,
                    and the resulting SNR in dB increases by approximately 6 dB for every additional bit of
                    the quantizer, given the assumptions of uniform distribution and full-range signals.
                </p>

            </mat-card-content>

        </mat-card>
    </div>









    <!-- Test section  -->


    <div class="flex flex-col items-center p-3 gap-6">
        <h2 class="text-2xl font-sans font-semibold mb-4">üß† Test Your Knowledge</h2>

        <div *ngFor="let q of questions" class="w-full md:w-2/3">
            <mat-card class="mat-elevation-z6 p-6 font-sans">
                <mat-card-title>{{ q.text }}</mat-card-title>
                <br>

                <mat-card-content>
                    <mat-radio-group [(ngModel)]="q.selectedAnswer" [disabled]="q.isSubmitted">
                        <div *ngFor="let option of q.options" class="mb-2">
                            <mat-radio-button [value]="option">{{ option }}</mat-radio-button>
                        </div>
                    </mat-radio-group>

                    <div class="mt-4 flex gap-3">
                        <button matFab extended (click)="submitAnswer(q)"
                            [disabled]="!q.selectedAnswer || q.isSubmitted">
                            Submit
                        </button>

                        <button matFab extended style="background-color:black ; color: aliceblue;" *ngIf="q.isSubmitted"
                            (click)="tryAgain(q)">
                            Try Again
                        </button>
                    </div>

                    <div class="mt-4">
                        <p *ngIf="q.isSubmitted && q.selectedAnswer === q.correctAnswer"
                            class="text-green-600 font-semibold font-sans">
                            ‚úÖ Correct!
                        </p>
                        <p *ngIf="q.isSubmitted && q.selectedAnswer !== q.correctAnswer"
                            class="text-red-600 font-semibold font-sans">
                            ‚ùå Incorrect. Correct answer: <strong>{{ q.correctAnswer }}</strong>.
                        </p>
                    </div>
                </mat-card-content>
            </mat-card>
        </div>
    </div>



</div>