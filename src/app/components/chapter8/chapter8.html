<div class="m-5 overflow-hidden grid gap-6">
    <div class=" text-3xl font-sans font-semibold">
        <h1>Chapter 8 : Filters, Noble Identities</h1>
    </div>

    <div>
        <mat-card class="example-card text-2xl" appearance="outlined">
            <mat-card-header>
                <mat-card-title style="color: blue;">1. Learning Objectives</mat-card-title>
            </mat-card-header>
            <br>
            <mat-card-content class="text-lg">

                <p>
                    In this chapter, the goal is to understand how filtering interacts with sampling in multirate
                    systems and how the Noble Identities help simplify these structures. Learners will explore how
                    filters can be rearranged with down-sampling and up-sampling operations and how polyphase
                    representation allows filters to operate efficiently at lower sampling rates. The chapter also aims
                    to show how these identities enable computational savings while preserving signal behavior.
                </p>


            </mat-card-content>

        </mat-card>


    </div>



    <div>
        <mat-card class="example-card text-2xl" appearance="outlined">
            <mat-card-header>
                <mat-card-title style="color: blue;">8.1. Theory</mat-card-title>
            </mat-card-header>

            <mat-card-content class="text-lg">
                <h1 class="mt-3 font-semibold"> 1. Filter Design</h1>
                <p class="mt-4">


                    How do we design filters, such that they have desired properties? First we should know
                    how the ideal or desired filter should look like. In general, we specify the frequency
                    responses with magnitude and phase,
                </p>


                <p class="mt-4">
                    How do we design filters so that they have the desired properties? First, we need to
                    know how the ideal or desired filter should look. In general, we specify the frequency
                    response using a magnitude term and a phase term.
                </p>

                <p class="mt-4">
                    The frequency response is written in the form:
                </p>

                <p class="text-center mt-3 text-lg font-mono">
                    H(Omega) = exp(j * phi(Omega)) * A(Omega)
                </p>

                <p class="mt-4">
                    phi(Omega) is the phase as a function of the normalized frequency Omega, and
                    A(Omega) is the magnitude. When designing a filter, we must specify both the phase
                    and the magnitude.
                </p>

                <h3 class="mt-4 text-xl">1.1 Phase and Signal Delay</h3>

                <p class="mt-4">

                    The phase angle of a system is directly connected to the delay introduced by that system.
                    Consider a pure delay of <code>d</code> samples, which has the transfer function:
                </p>
                <p class="text-center mt-3 text-lg font-mono">
                    H(z) = z^(-d)
                </p>


                <p class="mt-4">

                    To obtain the frequency response in the Discrete Time Fourier Transform (DTFT)
                    domain, we replace <code>z</code> with <code>exp(j * Omega)</code>:
                </p>
                <p class="text-center mt-3 text-lg font-mono">
                    H(exp(j * Omega)) = exp(-j * Omega * d)
                </p>


                <p class="mt-4">

                    Thus the phase response is:
                </p>
                <p class="text-center mt-3 text-lg font-mono">
                    phi(Omega) = angle(exp(-j * Omega * d)) = -Omega * d
                </p>

                <p class="mt-4">

                    Conversely, we can obtain the delay in samples by dividing the phase angle by the
                    normalized frequency:
                </p>
                <p class="text-center mt-3 text-lg font-mono">
                    d = -angle(H(exp(j * Omega))) / Omega
                </p>


                <p class="mt-4">

                    In Python, the function <code>np.angle()</code> returns the angle of a complex number in radians
                    (between 0 and 2œÄ), matching our normalized frequency range.
                </p>

                <p class="mt-4">

                    If the phase angle is a linear function of Omega with slope <code>-d</code>, the system is said to
                    have <b>linear phase</b>. Only in this case do all frequencies experience the same delay.
                    This is crucial in applications like image processing: edges contain many frequencies,
                    and different delays across frequencies would blur the edges.
                </p>

                <p class="mt-4">

                    In general, the negative derivative of the phase with respect to Omega is called the
                    <b>group delay</b>. If the group delay is written as <code>d_g(Omega)</code>, it is defined as:
                </p>
                <p class="text-center mt-3 text-lg font-mono">
                    d_g(Omega) = - d(phi(Omega)) / d(Omega)
                </p>

                <p class="mt-4">

                    This tells us how much delay each frequency component experiences when passing
                    through the system. When designing filters, understanding and controlling this delay
                    behavior is essential.
                </p>

            </mat-card-content>
        </mat-card>
    </div>





    <div>
        <mat-card class="example-card text-2xl" appearance="outlined">

            <mat-card-content class="text-lg">
                <h3 class="text-xl font-semibold font-mono ">8.1.2 Magnitude Design</h3>

                <p class="mt-4">
                    To design a filter, we must specify the desired magnitude response A(Omega). Many filters
                    aim to have one or more pass bands, where the signal is passed with nearly 0 dB attenuation,
                    and one or more stop bands, where the signal is strongly attenuated. To achieve this, the
                    band edges must be defined in normalized frequency.
                </p>

                <p class="mt-4">
                    For an FIR filter, the filter coefficients correspond to its impulse response. The ideal impulse
                    response can be obtained from the desired frequency response H(exp(j * Omega)) using the
                    inverse DTFT:
                </p>
                <p class="text-center mt-3 text-lg font-mono">
                    h(n) = (1 / (2*pi)) * integral from -pi to pi of [ H(exp(j * Omega)) * exp(j * Omega * n) dOmega ]
                </p>


                <p class="mt-4">
                    This impulse response is infinitely long and extends into the past and future. Because such
                    an ideal filter cannot be realized, we must approximate the desired frequency response by
                    minimizing some error function. The choice of error function depends on the requirements
                    of the application.
                </p>

                <p class="mt-4">
                    Since real filters cannot have perfect transitions, every design must include a transition band
                    between each pass band and stop band. This band provides space for the filter to move from
                    passing the signal to rejecting it.
                </p>

                <p class="mt-4"><b>Example:</b>
                    Consider designing a half-band low-pass filter. We want the pass band from 0 to pi/2.
                    For sampling-rate conversion with a downsampling factor of 2, the stop band must begin
                    at pi/2.
                    To provide a transition, we might define the transition band from (pi/2 - 0.1) to pi/2.
                    The pass band is then from 0 to (pi/2 - 0.1).
                </p>

                <p class="mt-4">
                    This is still an idealized description because the stop band attenuation is infinite. To produce
                    a realizable filter, we define an error measure that evaluates how close the filter comes to the
                    ideal response.
                </p>

                <p class="mt-4">
                    Common error functions include:
                </p>
                <ul>
                    <li>Mean squared error</li>
                    <li>Mean absolute error</li>
                    <li>Weighted mean squared error</li>
                    <li>Minimax error (minimize the maximum deviation)</li>
                </ul>

                <p class="mt-4">
                    In a weighted mean squared error, different weights are assigned to different frequency
                    regions. Typically, the stop band is given a larger weight because errors there result in
                    poorer attenuation. For example, a weight of 1 may be used in the pass band and 1000 in
                    the stop band to encourage a much stronger stop-band attenuation.
                </p>

                <p class="mt-4">
                    The optimization usually produces equal or proportional errors across the band. For example:
                </p>

                <pre class="bg-gray-100 text-sm p-3 rounded-lg overflow-x-auto font-mono mt-2">

error_stop_band * 1000 = error_pass_band * 1

</pre>

                <p class="mt-4">
                    Thus, the stop-band error becomes the pass-band error divided by 1000.
                </p>

                <p class="mt-4">
                    For FIR linear-phase filters, Python provides the <code>remez</code> function, which implements
                    the Parks‚ÄìMcClellan algorithm based on the Chebyshev approximation. This algorithm
                    minimizes the maximum error in each band (with weights), producing an equiripple
                    response: all ripples have equal height in each band.
                </p>

                <p class="mt-4">
                    The function is used as:
                </p>

                <pre class="bg-gray-100 text-sm p-3 rounded-lg overflow-x-auto font-mono mt-2">

h_min = scipy.signal.remez(N, F, A, W)

</pre>
            </mat-card-content>

        </mat-card>


    </div>
    <div class="h-6"></div>
    <div>
        <mat-card class="example-card text-2xl" appearance="outlined">

            <mat-card-content class="text-lg">
                <h3 class="text-2xl font-semibold font-sans ">
                    8.1.3 Python Example
                </h3>
                <pre class="bg-gray-100 text-sm p-3 rounded-lg overflow-x-auto font-mono mt-2">

ipython --pylab
import scipy.signal as sp
N=8;
F = [0.0, 0.5/2 - 0.05, 0.5/2, 0.5]
A = [1.0, 0.0]
W = [1, 100]
hmin = sp.remez(N, F, A, weight=W)
plot(hmin)
xlabel(‚ÄôSample‚Äô)
ylabel(‚ÄôValue‚Äô)

</pre>
                <div class="flex flex-col justify-around items-center gap-2">
                    <img src="assets/images/chap8/fig8.1.png" class="w-180 h-110 ">


                </div>

                <p class="mt-4">
                    Now we obtain a nice impulse response or set of coefficients hmin, which can be seen in
                    Fig. (8.1). and its frequencies response is obtained with
                </p>
                <pre class="bg-gray-100 text-sm p-3 rounded-lg overflow-x-auto font-mono mt-2">

from freqz import freqz
freqz(hmin)

</pre>
                <p class="mt-4">
                    and can be seen in Fig. (8.2).
                    Here we see that we obtain an amplitude gain of about -40 dB in the stop band, or
                    about 40 dB of stop band attenuation, which roughly corresponds to our weight of 100
                    for the stop band.

                </p>
                <p class="mt-4">
                    The phase (angle) plot has straight lines, which shows that this is a linear phase filter.
                    Observe that the angle is 2œÄ periodic, hence this plot is not unique and has jumps. The
                    magnitude has zero crossings (where the dips go down), and at those points there are
                    sign changes, phase jumps by œÄ, which is also why we see the jumps in the phase plot.
                </p>
            </mat-card-content>

        </mat-card>
    </div>
    <div>
        <mat-card class="example-card text-2xl" appearance="outlined">

            <mat-card-content class="text-lg">
                <h3 class="text-2xl font-semibold font-sans " style="color: blue;">
                    8.1.4 Example with Sound
                </h3>


                <p class="mt-4">
                    We have 8000 Hz sampling rate, and want to build a band pass filter. Our low stop
                    band is between 0 and 0.05, our pass band between 0.1 and 0.2, and high stop band
                    between 0.3 and 0.5 (again with 0.5 as Nyquist frequency and 1 as sampling frequency).

                    ![Screenshot 2025-11-18
                    172759.png](attachment:4f97c1b9-24f9-4ed5-9055-9758ff82b183:Screenshot_2025-11-18_172759.png)

                    Hence, our pass band will be between 0.1*8000=800Hz and 0.2*8000=1600 Hz. Hence
                    our vector of bands is
                    F=[0.0, 0.05, 0.1, 0.2, 0.3, 0.5]
                    The vector desired contains the desired magnitude A per band. Hence here for our
                    bandpass filter it is:
                    A=[0.0, 1.0, 0.0]
                    We choose our weights to:
                    weight=[100.0, 1.0, 100.0]
                    and our numtaps N= 32.
                    Hence our design function in Python is:
                </p>
                <div class="flex flex-col justify-around items-center gap-2">
                    <img src="assets/images/chap8/fig8.2.png" class="w-180 h-110 ">


                </div>
                <pre class="bg-gray-100 text-sm p-3 rounded-lg overflow-x-auto font-mono mt-2">

python3
import numpy as np
import scipy.signal
import matplotlib.pyplot as plt
N=32
bpass=scipy.signal.remez(N, [0.0, 0.05, 0.1, 0.2, 0.3, 0.5] ,\
[0.0, 1.0, 0.0], weight=[100.0, 1.0, 100.0])
[freq, response] = scipy.signal.freqz(bpass)
plt.plot(freq, 20*np.log10(np.abs(response)+1e-6))
plt.xlabel(‚ÄôNormalized Frequency (pi is Nyquist Frequency)‚Äô)
plt.ylabel(Magnitude of Frequency Response in dB)
plt.title(Magnitude of Frequency Response for our Bandbass Filter)
plt.show()

</pre>
                <p class="mt-4">
                    The resulting plot can be seen in Fig. (8.3). Observe: The equi-ripple behaviour inside each band is
                    clearly visible, and we see our pass band a little left of the center. The side
                    lobe to its right is from the transition band there.
                    Next we plot its impulse response,

                </p>


                <div class="flex flex-col justify-around items-center gap-2">
                    <img src="assets/images/chap8/fig8.3.png" class="w-180 h-110 ">


                </div>

                <pre class="bg-gray-100 text-sm p-3 rounded-lg overflow-x-auto font-mono mt-2">

plt.plot(bpass)
plt.title(‚ÄôImpulse Response of our Bandpass Filter‚Äô)
plt.show()

</pre>

                <p class=" mt-3 ">which can be seen in Fig. (8.4).
                    Observe: The impulse response is symmetric around the center, because it is a linear
                    phase filter, and it still has similarity with a sinc function.
                    Now try it on life audio with our python script:</p>


                <pre class="bg-gray-100 text-sm p-3 rounded-lg overflow-x-auto font-mono mt-2">
    python pyrecplay_filterblock.py
</pre>

                <div class="flex flex-col justify-around items-center gap-2">
                    <img src="assets/images/chap8/fig8.4.png" class="w-180 h-110 ">


                </div>
                <p class=" mt-3 ">
                    Observe: Speech sounds like through a very cheap telephone, since only a small band
                    is left of it (telephone bandwidth is about 0.3 to 3.4 kHz).
                    You can compare it to the non-filtered version by commenting out the
                    "data=struct.pack(..filtered..)"
                    line.
                </p>
            </mat-card-content>

        </mat-card>
    </div>
    <div>
        <mat-card class="example-card text-2xl" appearance="outlined">

            <mat-card-content class="text-lg">
                <h3 class="text-2xl font-semibold font-sans " style="color: blue;">
                    8.2 Filtering and Sampling, Multirate Noble Identities
                </h3>


                <p class="mt-4">
                    This section discusses filtering and sampling in multirate systems. The Noble Identities describe
                    when
                    filtering can be exchanged with downsampling or upsampling.
                </p>

                <p class="mt-4">
                    The identities can be written in plain text as:
                </p>

                <p class="mt-4">
                    Downsampling by N followed by filter H(z)<br>
                    = filter H(z raised to the power N) followed by downsampling by N
                </p>

                <p class="mt-4">
                    Upsampling by N followed by filter H(z)<br>
                    = filter H(z raised to the power N) followed by upsampling by N
                </p>

                <p class="mt-4">
                    Downsampling by N means keeping every Nth sample.
                    Upsampling by N means inserting N-1 zeros between each sample.
                    The operator symbol means applying one block after another (left to right).
                </p>

                <div class="flex flex-col justify-around items-center gap-2">
                    <img src="assets/images/chap8/fig8.5.png" class="w-180 h-110 ">


                </div>
                <div class="flex flex-col justify-around items-center gap-2">
                    <img src="assets/images/chap8/fig8.6.png" class="w-180 h-110 ">


                </div>
                <p class="mt-4">
                    If we take H(z) and replace z with z raised to N, the impulse response becomes upsampled.
                    For example:
                </p>

                <p class="text-center mt-3 text-lg font-mono">
                    H(z squared) = 1 + 2 z^(-2) + 3 z^(-4)
                </p>

                <p class="mt-4">
                    The corresponding impulse response is:
                </p>

                <p class="text-center mt-3 text-lg font-mono">
                    h_up = [1, 0, 2, 0, 3]
                </p>

                <p class="mt-4">
                    This happens because inserting zeros between coefficients spreads the impulse response.
                    The Noble Identities show when sampling and filtering can be swapped without changing the result,
                    which usually requires a sparse (zero-inserted) impulse response.
                </p>

                <p class="mt-4">
                    However, using H(z raised to N) normally creates N repeated frequency bands due to aliasing.
                    This makes the upsampled filter unusable by itself for most applications, unless additional
                    processing
                    is applied later.
                </p>

                <h4>Example</h4>

                <p class="mt-4">
                    Take a simple running-average FIR filter:
                </p>

                <p class="text-center mt-3 text-lg font-mono">
                    B = [1, 1]
                </p>

                <p class="mt-4">
                    And an input signal:
                </p>

                <p class="text-center mt-3 text-lg font-mono">
                    x = [1, 2, 3, 4, ...]
                </p>

                <p class="mt-4">
                    Python example:
                </p>

                <p class="text-center mt-3 text-lg font-mono">
                    x = np.arange(1, 10, dtype='float')<br>
                    N = 2
                </p>

                <p class="mt-4">
                    We can now implement the first Noble Identity block diagram, corresponding to the
                    downsampling case (the first pair, producing outputs y1 and y2).
                </p>
                <div class="flex flex-col justify-around items-center gap-2">
                    <img src="assets/images/chap8/fig8.7.png" class="w-180 h-110 ">


                </div>
                <p class="mt-4">-> First, for y1, first down sampling, then filtering, the down-sampling by a factor of
                </p>

                <pre class="bg-gray-100 text-sm p-3 rounded-lg overflow-x-auto font-mono mt-2">

N=2:
xd = x[::N]
This yields
xd=1,3,5,7,9
Then apply the filter B=[1,1],
y1 = scipy.signal.lfilter(B, 1, xd)
This yields the sum of each pair in xd:
y1= 1,4,8,12,16
-> Now first filtering, then down sampling, to implement the corresponding right-hand
side block diagram of the noble identity. Our filter is now up-sampled by N=2:
Bu = np.zeros(3)
Bu[::N] = B
This yields Bu= 1,0,1
Now filter the signal before down-sampling:
yu = scipy.signal.lfilter(Bu, 1, x)
This yields
yu= 1, 2, 4, 6, 8, 10, 12, 14, 16, 18
Now down-sample it:
y2 = yu[::N]
This yields
y2= 1,4,8,12,16
Here we can now see that they are indeed identical, y1=y2!

</pre>

            </mat-card-content>

        </mat-card>
    </div>
    <div>
        <mat-card class="example-card text-2xl" appearance="outlined">

            <mat-card-content class="text-lg">
                <h3 class="text-2xl font-semibold font-sans ">
                    8.3 Polyphase Representation
                </h3>





                <p class="mt-4">
                    The Noble identities allow the construction of efficient sampling-rate‚Äìconversion systems.
                    Using them, we can design filters that operate at lower sampling rates, reducing computational
                    cost. Normally, filtering was performed at the high sampling rate, but polyphase decomposition
                    makes low-rate filtering possible.
                </p>

                <p class="mt-4">
                    Any filter H(z) can be rewritten as a sum of delayed and upsampled versions of its
                    phase-shifted and downsampled impulse response. This creates useful filters from the otherwise
                    unusable upsampled versions produced by replacing z with z to the power N.
                </p>

                <p class="mt-4">
                    The general polyphase decomposition of a filter is:
                </p>

                <p class="mt-4">
                    H(z) = H0(z raised to N) + H1(z raised to N) multiplied by z^(-1)
                    + ... + H(N-1)(z raised to N) multiplied by z^(-(N-1))
                </p>

                <p class="mt-4">
                    H0(z raised to N) contains the coefficients of the original filter at positions mN (phase 0).<br>
                    H1(z raised to N) contains the coefficients at positions mN + 1 (phase 1).<br>
                    In general, Hi(z) contains the coefficients at positions mN + i (phase i).
                </p>

                <p class="mt-4">
                    Hi(z) is the z-transform of h(mN + i), where h(n) is the impulse response of the original filter.
                    Because i represents a phase index, the functions Hi(z) are called <strong>polyphase
                        components</strong>.
                </p>

                <p class="mt-4">
                    Figures (8.8) and (8.9) show how a simple signal can be decomposed into N upsampled polyphase
                    components for N = 3. Each component contains zeros inserted between samples.
                </p>

                <p class="mt-4">
                    The same applies to the signal x(n): the polyphase component Xi(z) is the z-transform of x(mN + i).
                </p>

                <h4>Example</h4>

                <p class="mt-4">
                    Suppose the filter impulse response is:
                </p>

                <p class="text-center mt-3 text-lg font-mono">
                    h = [1, 2, 3, 4, ...]
                </p>

                <p class="mt-4">
                    Its z-transform is:
                </p>

                <p class="text-center mt-3 text-lg font-mono">
                    H(z) = 1 + 2 z^(-1) + 3 z^(-2) + 4 z^(-3) + ...
                </p>

                <p class="mt-4">
                    With N = 2, the polyphase components become:
                </p>

                <p class="text-center mt-3 text-lg font-mono">
                    H0(z squared) = 1 + 3 z^(-2) + 5 z^(-4) + ...<br>
                    H1(z squared) = 2 + 4 z^(-2) + 6 z^(-4) + ...
                </p>

                <p class="mt-4">
                    Thus the complete filter can be reconstructed as:
                </p>

                <p class="text-center mt-3 text-lg font-mono">
                    H(z) = H0(z squared) + z^(-1) multiplied by H1(z squared)
                </p>

                <p class="mt-4">
                    A block diagram (Fig. 8.10) illustrates this structure: a delay chain on the left implements
                    delays z^(-i), and each branch contains a polyphase component Hi(z raised to N).
                </p>

                <p class="mt-4">
                    In a sampling-rate‚Äìconversion system, the input signal x(n) is low-pass filtered to prevent
                    aliasing,
                    then downsampled. Decomposing the filter into N polyphase components allows the filtering
                    to occur at the lower output sampling rate.
                </p>

                <p class="mt-4">
                    Using the Noble identities, we move the downsamplers before the filters and before the summation
                    (and not before the delay chain). This transforms Hi(z raised to N) into Hi(z), greatly simplifying
                    the system (as shown in Fig. 8.11).
                </p>

                <p class="mt-4">
                    The delay chain followed by downsampling corresponds to grouping x(n) into blocks of size N,
                    like serial-to-parallel conversion. Filtering now happens on these blocks at the low sampling rate.
                    This provides parallel processing with reduced computational load.
                </p>

                <p class="mt-4">
                    Since we have N polyphase components in parallel, they can be arranged into vectors:
                </p>

                <p class="mt-4">
                    Sum over i from 0 to N-1 of Xi(z) times Hi(z) equals Y(z)
                </p>

                <p class="mt-4">
                    This can be expressed as a vector multiplication:
                </p>

                <p class="text-center mt-3 text-lg font-mono">
                    [X0(z), ..., X(N-1)(z)] multiplied by [H0(z), ..., H(N-1)(z)]<sup>T</sup> = Y(z)
                </p>

                <p class="mt-4">
                    If multiple filters exist, polyphase vectors can be grouped into <strong>polyphase
                        matrices</strong>.
                </p>

                <p class="mt-4">
                    This representation is mathematically powerful because sampling is embedded directly
                    into this simple vector multiplication.
                </p>

                <div class="flex flex-col justify-around items-center gap-2">
                    <img src="assets/images/chap8/fig8.8.png" class="w-180 h-110 ">
                </div>


                <div class="flex flex-col justify-around items-center gap-2">
                    <img src="assets/images/chap8/fig8.9.png" class="w-180 h-110 ">
                </div>


              


                <div class="flex flex-col justify-around items-center gap-2">
                    <img src="assets/images/chap8/fig8.11.png" class="w-180 h-110 ">
                </div>
            </mat-card-content>

        </mat-card>
    </div>


   

    <div>
        <mat-card class="example-card text-2xl" appearance="outlined">

            <mat-card-content class="text-lg">
                <h3 class="text-2xl font-semibold font-sans" style="color: blue;">
                    8.3.2 Noble Identities for Upsampling
                </h3>

                <p class="mt-4">
                    Correspondingly, up-samplers can also be implemented with filters operating at the lower sampling
                    rate. Since Hi(z^N) and z^-i are linear time-invariant systems, we can exchange their ordering:
                </p>

                <p class="text-center mt-3 text-lg font-mono">
                    Hi(z^N) * z^-i = z^-i * Hi(z^N)
                </p>

                <p class="mt-4">
                    Hence, we can redraw the polyphase decomposition for an up-sampler followed by a low-pass filter (at
                    the high sampling rate), with the delay elements shifted to the output.
                </p>

                <p class="mt-4">
                    Thus, for upsampling followed by low-pass filtering, we obtain the structure illustrated in Fig.
                    8.12.
                </p>

                <p class="mt-4">
                    Using the Noble Identities, we can now shift the up-sampler to the right, behind the polyphase
                    filters (changing their arguments from z^N to z) and before the delay chain, with polyphase
                    components Yi(z), as shown in Fig. 8.13.
                </p>

                <p class="mt-4">
                    Again, this leads to parallel processing, with N filters working in parallel at the lower sampling
                    rate. The structure on the right, with the up-sampler and the delay chain, can be seen as a
                    de-blocking operation. Each time the up-sampler lets a complete block through, it is given to the
                    delay chain. In the next time-steps the up-sampler stops letting data through and produces N-1
                    zeros, and the block is shifted through the delay chain as a sequence of samples. This can also be
                    seen as a parallel-to-serial conversion.
                </p>

                <p class="mt-4">
                    With the polyphase elements Yi(z), the processing at the lower sampling rate can also be written in
                    terms of polyphase vectors:
                </p>

                <p class="text-center mt-3 text-lg font-mono">
                    Y(z) * [ H0(z), ..., H(N-1)(z) ] = [ Y0(z), ..., Y(N-1)(z) ]
                </p>

                <p class="mt-4">
                    Observe: If we have more than one filter, we can collect their polyphase vectors into polyphase
                    matrices.
                </p>

            <div class="flex flex-col justify-around items-center gap-2">
                    <img src="assets/images/chap8/fig8.12.png" class="w-180 h-110 "> 
                </div>


            </mat-card-content>

        </mat-card>
    </div>


    <div>
        <mat-card class="example-card text-2xl" appearance="outlined">

            <mat-card-content class="text-lg">
                <h3 class="text-2xl font-semibold font-sans " style="color: blue;">
                   8.3.3 Example Upsampling
                </h3>
                <pre class="bg-gray-100 text-sm p-3 rounded-lg overflow-x-auto font-mono mt-2">

ipython --pylab
import scipy.signal
from sound import *
#up-sample the signal y by a factor of N=2 and
#low-pass filter it with the filter
h = np.array([0.5, 1, 1.1, 0.6])
#as in the previous example. Again we obtain the filters
#polyphase components as
h0 = h[0::2]
h1 = h[1::2]...

</pre>

                <p class="mt-4">
                    Now we can use these polyphase components to filter at the lower sampling rate to obtain
                    the polyphase components of the filtered and upsampled signal y0 and y1. Again, watch
                    the structure above, where we got $[Y0(z), Y1(z)] = Y (z) ¬∑ [H0(z), H1(z)]$, where Y is the
                    signal at the lower sampling rate, and observe that the multiplicazion in the z-domain
                    turns into a filtering operation in the time domain. y came out of our above example
                    for sampling rate reduction. This is where we can now continue for up-sampling:
                </p>
 <pre class="bg-gray-100 text-sm p-3 rounded-lg overflow-x-auto font-mono mt-2">


y0 = scipy.signal.lfilter(h0,1,y)
y1 = scipy.signal.lfilter(h1,1,y)

</pre>


                <p class="mt-4">
                    The complete up-sampling the signal is then obtained from its 2 polyphase components. Next we need
                    to upsample and do the phase delay (see the block diagram Picture
                    2), for our de-blocking:
                </p>

                 <pre class="bg-gray-100 text-sm p-3 rounded-lg overflow-x-auto font-mono mt-2">

L = max([len(y0), len(y1)])
yu = zeros(2*L)
#upsampling with phase 0:
yu[0::2] = y0
#upsampling with phase 1:
yu[1::2] = y1...

</pre>
               

                <p class="mt-4">
                    Where now the signal yu is the same as if we had first up-sampled and then filtered the
                    signal! Now listen to the up-sampled signal:
                </p>

                 <pre class="bg-gray-100 text-sm p-3 rounded-lg overflow-x-auto font-mono mt-2">

sound(yu*0.3,fs);

</pre>
            </mat-card-content>

        </mat-card>
    </div>



    <!-- Test section  -->
    <div class="h-6"></div>

    <div class="flex flex-col items-center p-3 gap-6">
        <h2 class="text-2xl font-sans font-semibold mb-4">üß† Test Your Knowledge</h2>

        <div *ngFor="let q of questions" class="w-full md:w-2/3">
            <mat-card class="mat-elevation-z6 p-6 font-sans">
                <mat-card-title>{{ q.text }}</mat-card-title>
                <br>

                <mat-card-content>
                    <mat-radio-group [(ngModel)]="q.selectedAnswer" [disabled]="q.isSubmitted">
                        <div *ngFor="let option of q.options" class="mb-2">
                            <mat-radio-button [value]="option">{{ option }}</mat-radio-button>
                        </div>
                    </mat-radio-group>

                    <div class="mt-4 flex gap-3">
                        <button matFab extended (click)="submitAnswer(q)"
                            [disabled]="!q.selectedAnswer || q.isSubmitted">
                            Submit
                        </button>

                        <button matFab extended style="background-color:black ; color: aliceblue;" *ngIf="q.isSubmitted"
                            (click)="tryAgain(q)">
                            Try Again
                        </button>
                    </div>

                    <div class="mt-4">
                        <p *ngIf="q.isSubmitted && q.selectedAnswer === q.correctAnswer"
                            class="text-green-600 font-semibold font-sans">
                            ‚úÖ Correct!
                        </p>
                        <p *ngIf="q.isSubmitted && q.selectedAnswer !== q.correctAnswer"
                            class="text-red-600 font-semibold font-sans">
                            ‚ùå Incorrect. Correct answer: <strong>{{ q.correctAnswer }}</strong>.
                        </p>
                    </div>
                </mat-card-content>
            </mat-card>
        </div>
    </div>



</div>