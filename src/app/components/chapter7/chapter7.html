<div class="m-5 overflow-hidden space-y-4 ">
  <div class=" text-3xl font-sans font-semibold">
    <h1>Chapter 7 : z-Transform, Filters</h1>
  </div>

  <div>
    <mat-card class="example-card text-2xl" appearance="outlined" style="background-color: #D9E9CF;">
      <mat-card-header>
        <mat-card-title style="color: blue;">1. Learning Objectives</mat-card-title>
      </mat-card-header>
      <br>
        <mat-card-content class="text-lg">
          <ul class="list-disc pl-6 space-y-2 mt-2 text-lg">
            <li>
              <strong>Understand</strong> the one-sided <em>z-transform</em>, the <strong>Region of
            Convergence (ROC)</strong>,
            and how a discrete delay maps to <code>z<sup>-1</sup></code>.
          </li>

          <li>
            <strong>Relate</strong> the Discrete-Time Fourier Transform (DTFT) to the <em>z-transform</em>
            via
            <code>z = r ¬∑ e<sup>jŒ©</sup></code> and evaluation on the <strong>unit circle</strong>
            (<code>r = 1</code>).
          </li>

          <li>
            <strong>Derive</strong> FIR/IIR difference equations and corresponding transfer functions
            (<code>H(z)</code>), and analyze <strong>stability</strong> via pole locations and ROC.
          </li>

          <li>
            <strong>Compute</strong> frequency responses <code>H(e<sup>jŒ©</sup>)</code>, generate pole/zero
            plots,
            and obtain impulse responses using <em>Python</em> (e.g., NumPy / SciPy).
          </li>
        </ul>

      </mat-card-content>

    </mat-card>


  </div>


  <div class="flex flex-col justify-around items-center gap-2">
    <img src="assets/images/chap7/chp8fig1.gif" class="w-150 h-120 ">
    <h1 class="text-wrap">
      Figure 7.1: Surface plot illustrating poles, zeros, and ROC in the z-domain.

    </h1>
  </div>


  <div>
    <mat-card class="example-card text-2xl" appearance="outlined">


      <mat-card-content class="text-lg">

        <h2 class="text-2xl font-semibold mb-4 font-sans">7.1 The z-Transform</h2>

        <p class="text-lg">
          The <strong>z-Transform</strong> is a more general transform than the Fourier Transform and is a
          key tool in
          achieving <em>perfect reconstruction</em> in filter banks and wavelets. To explore this, we
          analyze the effects
          of sampling and examine system behavior in the <strong>z-domain</strong>.
        </p>

        <p class="mt-4 text-lg">
          Since most practical systems are <strong>causal</strong>, we use the <em>one-sided
        z-Transform</em>, defined as:
      </p>

                <p class="text-lg font-mono mt-3 text-center" appMathJax="$$ X(z) = \sum_{n=0}^{\infty} x(n)z^{-n}

 $$">




        <p class="mt-4 text-lg">
          This representation turns the sequence <code>x(n)</code> into a <strong>polynomial in
        z</strong>. Notice that we
        obtain the usual <strong>frequency response</strong> (the DTFT for a causal signal) when we
        evaluate the
        z-transform along the unit circle in the z-plane:
      </p>

                <p class="text-lg font-mono mt-3 text-center" appMathJax="$$  z = e^{j\Omega}

 $$">

        <p class="mt-4 text-lg">
          This links the <strong>z-Transform</strong> with the <strong>Discrete-Time Fourier Transform
        (DTFT)</strong>,
        except for the index range: the one-sided z-transform starts at <em>n = 0</em>, while the DTFT
        includes
        <em>n = ‚àí‚àû</em>.
      </p>

      <p class="mt-4 text-lg">
        In general, the complex variable <code>z</code> can be written in polar form as:
      </p>

                <p class="text-lg font-mono mt-3 text-center" appMathJax="$$  z = r \cdot e^{j\Omega}

 $$">


        <p class="mt-4 text-lg">
          Here, <em>Œ©</em> is the normalized angular frequency, and <em>r</em> represents a
          <strong>damping factor</strong>.
          When <em>r &lt; 1</em>, the system exhibits exponentially decaying oscillations; when <em>r &gt;
        1</em>, it shows
        exponential growth.
      </p>

      <p class="mt-4 text-lg">
        Note that this damping factor does not appear in the DTFT. Thus, in the z-transform, the
        transform sum can still
        converge even for unstable signals or systems ‚Äî by selecting an appropriate <em>r</em>. This
        defines the
        <strong>Region of Convergence (ROC)</strong>.
      </p>
                <p class="text-lg font-mono mt-3 text-center" appMathJax="$$ z^{-1} = \frac{1}{r} \cdot e^{-j\Omega}

 $$">

        <p class="mt-4 text-lg">
          To grasp the essence of the z-Transform, it‚Äôs crucial to first understand the DTFT. The key is
          not just solving
          the equations, but <strong>understanding what the math represents</strong> in terms of system
          behavior and signal
          evolution.
        </p>

      </mat-card-content>
    </mat-card>
  </div>


  <div class="flex flex-col justify-around items-center gap-2">
    <img src="assets/images/chap7/fig8.2.gif" class="w-180 h-100 ">
    <h1 class="text-wrap">
      figure 7.2

    </h1>
  </div>



  <div>
    <mat-card class="example-card text-2xl" appearance="outlined">

      <mat-card-content class="text-lg">
        <title>Z-Transform Properties</title>
        <style>
          body {
          font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
          max-width: 900px;
          margin: 0 auto;
          padding: 20px;
          line-height: 1.8;
          color: #333;
          background: #f9fafb;
        }

        .container {
        background: white;
        padding: 40px;
        border-radius: 12px;
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
      }

      h2 {
      color: #2563eb;
      font-size: 28px;
      margin-bottom: 20px;
      border-bottom: 3px solid #2563eb;
      padding-bottom: 10px;
    }

    h3 {
    color: #1e40af;
    font-size: 22px;
    margin-top: 32px;
    margin-bottom: 12px;
  }

  h4 {
  color: #1e40af;
  font-size: 18px;
  margin-top: 24px;
  margin-bottom: 10px;
}

p {
margin: 12px 0;
font-size: 16px;
}

.formula {
background: #f3f4f6;
padding: 16px;
margin: 16px 0;
border-radius: 8px;
font-family: 'Courier New', monospace;
text-align: center;
border-left: 4px solid #2563eb;
font-size: 15px;
}

.example {
background: #eff6ff;
padding: 20px;
margin: 20px 0;
border-radius: 8px;
border-left: 4px solid #3b82f6;
}

.note {
background: #fef3c7;
padding: 16px;
margin: 20px 0;
border-radius: 8px;
border-left: 4px solid #f59e0b;
}

ul {
margin: 16px 0;
padding-left: 24px;
}

li {
margin: 8px 0;
}

.highlight {
background: #fef3c7;
padding: 2px 6px;
border-radius: 4px;
font-weight: 600;
}

strong {
color: #1e40af;
}

.inline-math {
font-family: 'Courier New', monospace;
background: #f3f4f6;
padding: 2px 6px;
border-radius: 4px;
}
</style>

<body>

  <h2>7.1.1 Properties of the z-Transform</h2>

  <h3>1. Shift Property</h3>

  <p>Take two causal sequences (causal means sample value 0 for negative indices): Sequence <span
    class="inline-math">x(n)</span>, and <span class="inline-math">x(n-1)</span>, which is
  the same sequence but delayed by one sample. Then their z-transforms are:</p>

                    <p class="text-lg font-mono mt-3 text-center" appMathJax="$$ x(n) \to \sum_{n=0}^{\infty} x(n) \cdot z^{-n} =: X(z)

 $$">
  </p>

                    <p class="text-lg font-mono mt-3 text-center" appMathJax="$$ x(n - 1) \to \sum_{n=0}^{\infty} x(n - 1) \cdot z^{-n} = \sum_{n=1}^{\infty} x(n - 1) \cdot z^{-n}

 $$">
  </p>



  <p>Use the index substitution, <span class="inline-math">n' ‚Üê n-1</span> or <span
class="inline-math">n'+1 ‚Üê n</span> to get rid of the "n-1" in the transform:</p>
                    <p class="text-lg font-mono mt-3 text-center" appMathJax="$$ = \sum_{n'=0}^{\infty} x(n') \cdot z^{-(n'+1)} = z^{-1} \cdot \sum_{n'=0}^{\infty} x(n') \cdot z^{-n'} = X(z) \cdot z^{-1}

 $$">
</p>


<p>This shows that a delay by 1 sample in the signal sequence (time domain) corresponds to the
  multiplication with <span class="highlight">z^(-1)</span> in the z-domain:</p>

                    <p class="text-lg font-mono mt-3 text-center" appMathJax="$$ x(n) \to X(z)

 $$">
  </p>
                    <p class="text-lg font-mono mt-3 text-center" appMathJax="$$ x(n - 1) \to X(z) \cdot z^{-1}

 $$">
  </p>

  <div class="example">
    <h4>Example:</h4>
    <p>Take an example signal: <span class="inline-math">x0 = [1, 2, 3]</span> ‚áí <span
  class="inline-math">X0(z) = 1 + 2¬∑z^(-1) + 3¬∑z^(-2)</span></p>
  <p>And this signal, delayed by 1 sampling period: <span class="inline-math">x1 = [0, 1, 2,
  3]</span> ‚áí <span class="inline-math">X1(z) = 0 + 1¬∑z^(-1) + 2¬∑z^(-2) +
3¬∑z^(-3)</span></p>
<p>In the z-domain this delay shows up as multiplication with <span
class="inline-math">z^(-1)</span>:</p>

                        <p class="text-lg font-mono mt-3 text-center" appMathJax="$$  = X_0(z) \cdot z^{-1}

 $$">
</p>

</div>

<h4>Z-Transform of the Shifted Unit Pulse</h4>

<p>Related to the shift property is the z-transform of the shifted unit pulse. The unit pulse is
defined as:</p>

                    <p class="text-lg font-mono mt-3 text-center" appMathJax="$$  \delta(n) = \begin{cases} 1, & \text{if } n = 0 \\ 0, & \text{else} \end{cases}

 $$">
</p>

<div class="formula">
  delta(n) = 1, if n = 0<br>
  delta(n) = 0, else
</div>

<p>So it is just a zero sequence with a 1 at time 0. Its z-Transform is then:</p>
                    <p class="text-lg font-mono mt-3 text-center" appMathJax="$$ \delta(n) \to 1

 $$">
</p>


<p>The z-transform of the shifted unit pulse delayed by <span class="inline-math">d</span>
samples is:</p>
                    <p class="text-lg font-mono mt-3 text-center" appMathJax="$$  \delta(n - d) \to z^{-d}

 $$">
</p>



<h4>Linearity Property</h4>

<p>Using the linearity property of the z-transform yields:</p>
                    <p class="text-lg font-mono mt-3 text-center" appMathJax="$$ a \cdot x(n) \to a \cdot X(z)

 $$">
</p>

                    <p class="text-lg font-mono mt-3 text-center" appMathJax="$$ x(n) + y(n) \to X(z) + Y(z)

 $$">
</p>



<h3>2. Convolution Property</h3>
                    <p class="text-lg font-mono mt-3 text-center" appMathJax="$$ x(n) \ast y(n) \to X(z) \cdot Y(z)

 $$">
</p>


<p>The z-transform turns a convolution into a multiplication. Remember that the convolution is
defined as:</p>
                    <p class="text-lg font-mono mt-3 text-center" appMathJax="$$ x(n) \ast y(n) = \sum_{m=-\infty}^{\infty} x(m) \cdot y(n - m)

 $$">
</p>



<p>This is because the convolution of 2 sequences behave in the same way as the multiplication
  of 2 polynomials (the z-transforms) of these sequences. This is one of the main advantages
  of the z-Transform, since it turns convolution into a simpler multiplication (which in
principle is invertible).</p>

<div class="example">
  <h4>Example: Exponential Decaying Sequence</h4>

  <p>The example signal is an exponential decaying sequence:</p>
                        <p class="text-lg font-mono mt-3 text-center" appMathJax="$$ x(n) = p^n

 $$">
  </p>


  <p>for n=0,1,..., meaning the sequence 1, p, p^2, p^3, ...</p>
                        <p class="text-lg font-mono mt-3 text-center" appMathJax="$$ X(z) = \sum_{n=0}^{\infty} p^n \cdot z^{-n}

 $$">
  </p>


  <p>Remember from last time: we had a closed form solution for this type of geometric sums:
  </p>
                        <p class="text-lg font-mono mt-3 text-center" appMathJax="$$ S = \sum_{k=0}^{N-1} c^k

                    S = \frac{c^N - 1}{c - 1}

 $$">
  </p>
  <p>
    solution:
  </p>

                        <p class="text-lg font-mono mt-3 text-center" appMathJax="$$ 
                    S = \frac{c^N - 1}{c - 1}

 $$">
    <p>But now we have an infinite sum, which means N goes towards infinity. But we have the
      expression <span class="inline-math">c^N</span> in the solution. If <span
    class="inline-math">|c| < 1</span>, then this goes to zero <span class="inline-math">c^N
  ‚Üí 0</span>. Now we have <span class="inline-math">c
  = p ¬∑ z^(-1)</span>. Hence, if <span class="inline-math">|p ¬∑ z^(-1)| < 1</span>
we get:</p>
                        <p class="text-lg font-mono mt-3 text-center" appMathJax="$$ \rightarrow X(z) = \frac{1}{1 - p \cdot z^{-1}} = \frac{z}{z - p} \tag{7.1}

 $$">
</p>

</div>

<h4>Poles and Zeros</h4>

<p>Observe that this fraction has a <strong>pole</strong> at position <span
class="inline-math">z=p</span>, and a <strong>zero</strong> at position <span
class="inline-math">z=0</span>. Hence if we know the pole position, we know <span
class="inline-math">p</span>, and if we know <span class="inline-math">p</span> we know
the time sequence (except for a constant factor). So the location of the pole gives us very
important information about the signal.</p>

<p>Keep in mind that this solution is only valid for all <span class="inline-math">p</span>
which fulfill <span class="inline-math">|p ¬∑ z^(-1)| < 1</span>. We see that this is true
for <span class="inline-math">|z| > |p|</span>. This is also called the
<strong>"Region of Convergence" (ROC)</strong>.</p>

<h3>Stability and Region of Convergence</h3>

<p>The ROC is connected to the resulting stability of the system or signal. The region of
  convergence is outside the pole locations. If the region of convergence includes the unit
  circle (which describes constant, bounded oscillations), we have a stable system. This
  means: <strong>if the poles are inside the unit circle, we have a stable system</strong>.
</p>

<p>The sum of <span class="inline-math">x(n)</span> converges (we get the sum if we set <span
class="inline-math">z = 1</span>) if <span class="inline-math">|p| < 1</span>. In this
case we also say that the signal or system is <strong>stable</strong> (meaning for a
bounded input we obtain a bounded output, so-called "BIBO stability"). In this case
we see that the resulting pole of our z-transform is inside the unit circle.</p>

<p>If <span class="inline-math">|p| > 1</span>, we have an exponential growth of the impulse
response, which is basically an "exploding" signal or system (meaning the output grows
towards infinity), hence it is <strong>unstable</strong>.</p>

<div class="note">
  <strong>General Rule:</strong> A system or a signal is stable if the poles of its
  z-transform are inside the unit circle in the z-domain, or unstable if at least one pole is
  outside the unit circle (it will exponentially grow).
</div>

<h4>Using Properties for Analysis</h4>

<p>These are basic properties, which can be used to derive z-transforms of more complicated
expressions, and they can also be used to obtain an inverse z-transform, by inspection.</p>

<p>For instance if we see a fraction with a pole in the z-Transform, we know that the underlying
time sequence has an exponential decay or oscillation in it.</p>

<p>Observe that we can obtain a real valued decayed oscillation if we have 2 poles, each the
  conjugate complex of the other, or one with <span class="inline-math">+Œ©</span> and one with
  <span class="inline-math">-Œ©</span>. In this way, we cancel the imaginary part.
</p>

<h4>Comparison with DTFT</h4>

<p>One of the main differences of the z-transform compared to the Discrete Time Fourier
  Transform (DTFT): With the z-transform we can see if a signal or system is stable by looking
  at the position of the poles in the z-domain. This is not possible for the DTFT, since there
we don't know the positions of the poles.</p>

<h3>Downsampling and Aliasing</h3>

<p>Now take a look at our downsampled signal from last time:</p>
                    <p class="text-lg font-mono mt-3 text-center" appMathJax="$$ x_d(n) = x(n) \cdot \Delta_N(n) = x(n) \cdot \frac{1}{N} \sum_{k=0}^{N-1} e^{j\frac{2\pi}{N} \cdot k \cdot n}

 $$">
</p>


<p>Now we can z-transform it:</p>
                    <p class="text-lg font-mono mt-3 text-center" appMathJax="$$ \sum_{n=0}^{\infty} x_d(n) \cdot z^{-n} = \sum_{n=0}^{\infty} x(n) \cdot \frac{1}{N} \sum_{k=0}^{N-1} e^{j\frac{2\pi}{N} \cdot k \cdot n} \cdot z^{-n}

 $$">
</p>


<p>Hence the effect of multiplying our signal with the delta impulse train in the z-domain is:
</p>
                    <p class="text-lg font-mono mt-3 text-center" appMathJax="$$ X_d(z) = \frac{1}{N} \sum_{k=0}^{N-1} X(e^{-j\frac{2\pi}{N} \cdot k} \cdot z)

 $$">
</p>


<p>Observe that here the <strong>aliasing components</strong> appear by multiplying <span
class="inline-math">z</span> with <span class="inline-math">e^(-j¬∑2œÄ/N¬∑k)</span>, which
in effect is a shift of the frequency.</p>

<p>Remember from last time, the effect of the removal or re-insertion of the zeros (changing the
  sampling rate) from or into the signal <span class="inline-math">x_d(n)</span> at the higher
  sampling rate and <span class="inline-math">y(m)</span> at the lower sampling rate. In the
z-domain is...</p>

</body>
</mat-card-content>

</mat-card>


</div>

<div>
  <mat-card class="example-card text-2xl" appearance="outlined">

    <mat-card-content class="text-lg">
      <h3 class="text-2xl font-semibold font-sans " style="color: blue;">
        7.2 Filters
      </h3>


      <p class="mt-4">

      </p>


      <p class="mt-4">
        Filters are linear, time-invariant systems. This means they fulfil the following properties:
      </p>

      <p>
        If F(x(n)) is our filter function of input signal x(n), then we have:
      </p>

      <ul>
        <li>
          <strong>Linearity:</strong> for two signals x‚ÇÅ(n) and x‚ÇÇ(n),
                        <p class="text-lg font-mono mt-3 text-center" appMathJax="$$ F(x_1(n) + x_2(n)) = F(x_1(n)) + F(x_2(n))

 $$">
          </p>


          <p>With a scaling factor a:</p>
                        <p class="text-lg font-mono mt-3 text-center" appMathJax="$$ F(a ¬∑ x(n)) = a ¬∑ F(x(n))

 $$">
          </p>

          <p>
            This means we can pull sums and constant factors out of the filter function.
          </p>
        </li>

        <li>
          <strong>Time-Invariance:</strong> if
                        <p class="text-lg font-mono mt-3 text-center" appMathJax="$$ y(n) = F(x(n))

 $$">
          </p>

          <p>then for a delay of n‚ÇÄ:</p>
                        <p class="text-lg font-mono mt-3 text-center" appMathJax="$$ y(n + n0) = F(x(n + n0))

 $$">
          </p>

          <p>
            This means the system behavior does not change with time.
          </p>
        </li>
      </ul>

      <h3>7.2.1 Finite Impulse Response (FIR) Filters</h3>

      <p>
        A simple Finite Impulse Response (FIR) filter has the following difference equation, where
        x(n) is the input and y(n) is the output:
      </p>
                <p class="text-lg font-mono mt-3 text-center" appMathJax="$$ y(n) = \sum_{m=0}^{M} b(m) x(n - m)

 $$">
      </p>


      <p>
        This operation is a convolution of the signal x(n) with the sequence b(n).
        The values b(m) are the filter coefficients, also called the impulse response.
      </p>

      <p>
        The coefficients b(n) are often called ‚Äútaps‚Äù because the filter can be viewed as tapping
        a delay line at different points.
      </p>

      <div class="flex flex-col justify-around items-center gap-2">
        <img src="assets/images/chap7/fig7.3.png" class="w-180 h-90 ">
      </div>

      <p>
        The dashed branches indicate additional delay-and-multiply stages that are not shown.
        This difference equation is how FIR filters are typically implemented in MATLAB or Python.
      </p>

      <p>
        In the time domain, blocks labeled z‚Åª¬π represent a delay of one sample, not a multiplication.
        After the first delay block we obtain x(n‚àí1), after the second delay block x(n‚àí2), and so on.
      </p>

      <p>
        Each delay block stores the input sample for one sampling period and releases it in the next cycle.
      </p>

      <p>
        Taking the z-transform of the difference equation gives:
      </p>
                <p class="text-lg font-mono mt-3 text-center" appMathJax="$$ y(n) = \sum_{m=0}^{M} b(m) x(n - m)

 $$">
      </p>
                <p class="text-lg font-mono mt-3 text-center" appMathJax="$$Y(z) = \sum_{m=0}^{M} b(m) \cdot z^{-m} \cdot X(z) = X(z) \cdot \sum_{m=0}^{M} b(m) \cdot z^{-m}
 $$">
      </p>


      <p>
        The transfer function is defined as the ratio of output to input:
      </p>
                <p class="text-lg font-mono mt-3 text-center" appMathJax="$$ H(z) := \frac{Y(z)}{X(z)} = \sum_{m=0}^{M} b(m) \cdot z^{-m}

 $$">
      </p>


      <p>
        This transfer function is simply the z-transform of the impulse response b(n).
      </p>

      <p>
        The frequency response of the filter is obtained by replacing z with
        exp(jŒ©), allowing us to analyze which frequencies are passed or attenuated.
      </p>
                <p class="text-lg font-mono mt-3 text-center" appMathJax="$$ H(e^{j\Omega}) = \sum_{m=0}^{M} b(m) \cdot e^{-j\Omega \cdot m}

 $$">
      </p>

      <h3>Frequency Response</h3>

      <p>
        Since exp(jŒ©) is a complex number, the frequency response is also complex.
        Therefore, H(exp(jŒ©)) is a complex value for each frequency Œ©.
      </p>

      <p>
        The frequency response is usually visualized using two plots:
      </p>

      <ul>
        <li><strong>Magnitude plot</strong> ‚Äì shows how much each frequency is amplified or attenuated</li>
        <li><strong>Phase plot</strong> ‚Äì shows the phase shift introduced at each frequency</li>
      </ul>

      <p>
        Using these two plots, we can design filters with desired properties,
        such as stop-bands or pass-bands at specific frequencies.
      </p>

      <p>
        In both MATLAB and Python, the function used to compute and plot
        the magnitude and phase response of a signal or transfer function is:
      </p>

      <pre>
        freqz
      </pre>

      <p>
        We have already encountered this function earlier.
      </p>

      <hr>

        <h3>7.2.2 Infinite Impulse Response (IIR) Filters</h3>

        <p>
          The difference equation of an Infinite Impulse Response (IIR) filter is:
        </p>
                <p class="text-lg font-mono mt-3 text-center" appMathJax="$$ y(n) = \sum_{m=0}^{M} b(m) \cdot x(n - m) + \sum_{r=1}^{N} a(r) \cdot y(n - r) \tag{7.2}
 $$">
        </p>


        <p>
          This equation contains two convolution operations:
        </p>

        <ul>
          <li>One convolution with the input signal x(n)</li>
          <li>One convolution with the past output values y(n)</li>
        </ul>

        <p>
          The second term represents feedback from the output back into the system.
          This feedback is what gives IIR filters their name: the impulse response
          theoretically lasts forever.
        </p>

        <p>
          Notice that the feedback terms start at y(n‚àí1) and not y(n).
          This avoids so-called <strong>delayless loops</strong>.
        </p>

        <p>
          A delayless loop would require the value y(n) before it has been computed,
          which is not physically or computationally possible.
        </p>

        <p>
          Just like FIR filters, this difference equation is the standard way
          IIR filters are implemented in MATLAB, Octave, and Python.
        </p>

        <p>
          In Python, IIR filters are commonly implemented using:
        </p>

        <pre>
          scipy.signal.lfilter
        </pre>

        <p>
          Figure 7.2 illustrates the corresponding block diagram of an IIR filter,
          showing both feedforward and feedback paths.
        </p>

        <div class="flex flex-col justify-around items-center gap-2">
          <img src="assets/images/chap7/fig7.4.png" class="w-180 h-110 ">
        </div>
        <p>
          Again, the boxes labeled z‚Åª¬π represent a delay of one sampling period,
          and the oval shapes represent a multiplication by the factor written next to them.
        </p>

        <p>
          The z-transform of the IIR filter difference equation (equation 7.2) can be written as:
        </p>
                <p class="text-lg font-mono mt-3 text-center" appMathJax="$$ Y(z) = \sum_{m=0}^{M} b(m) \cdot X(z) \cdot z^{-m} + \sum_{r=1}^{N} a(r) \cdot Y(z) \cdot z^{-r} \tag{7.3}

 $$">
        </p>

        <p>
          Important note:
          MATLAB, Octave, and Python‚Äôs <code>scipy.signal.lfilter</code>
          define the feedback coefficients <code>a</code> with opposite signs
          compared to the convention used here and in Oppenheim &amp; Schafer.
        </p>

        <p>
          You can verify this by checking:
        </p>

        <pre>
          help filter
          help(scipy.signal.lfilter)
        </pre>

        <hr>

          <h4>Transfer Function of an IIR Filter</h4>

          <p>
            To obtain the transfer function, we first move all terms containing Y(z)
            to one side of the equation:
          </p>
                <p class="text-lg font-mono mt-3 text-center" appMathJax="$$ Y(z)\left(1 - \sum_{r=1}^{N} a(r) \cdot z^{-r}\right) = X(z) \cdot \sum_{m=0}^{M} b(m) \cdot z^{-m}

 $$">
          </p>


          <p>
            Dividing the output by the input gives the transfer function:
          </p>
                <p class="text-lg font-mono mt-3 text-center" appMathJax="$$ H(z) = \frac{Y(z)}{X(z)} = \frac{\sum_{m=0}^{M} b(m) \cdot z^{-m}}{1 - \sum_{r=1}^{N} a(r) \cdot z^{-r}}

 $$">
          </p>


          <p>
            An important observation:
            Using the z-transform allows us to find a closed-form expression
            for the transfer function, even though the system contains feedback.
            This is a major advantage of the z-transform.
          </p>

          <p>
            Because the denominator is a polynomial in z‚Åª¬π, the transfer function
            contains poles. This means the filter can potentially become unstable.
          </p>

          <p>
            The zeros of the denominator polynomial correspond to the poles of the filter.
            If all poles lie strictly inside the unit circle, the filter is stable.
          </p>

          <p>
            Therefore, stability can be ensured by designing the coefficients a(n)
            such that all poles remain inside the unit circle.
          </p>

          <hr>

            <h3>7.2.3 IIR Filter with Minimum Number of Memory Elements</h3>

            <p>
              For hardware implementations, it is often desirable to minimize the number
              of required memory elements.
            </p>

            <p>
              This can be achieved by combining the memory elements of the feedforward
              and feedback paths of the IIR filter.
            </p>

            <p>
              To do this, we redefine:
            </p>

            <ul>
              <li>N as the maximum of M and N</li>
              <li>All coefficients beyond their original limits are set to zero</li>
            </ul>

            <p>
              With this assumption, the z-domain representation becomes:
            </p>
                <p class="text-lg font-mono mt-3 text-center" appMathJax="$$ Y(z) = b(0) \cdot X(z) + \sum_{m=1}^{N} z^{-m} \cdot (b(m) \cdot X(z) + a(m) \cdot Y(z))

 $$">
            </p>


            <p>
              This expression can be expanded as a nested delay structure:
            </p>
                <p class="text-lg font-mono mt-3 text-center" appMathJax="$$ Y(z) = b(0) \cdot X(z) + z^{-1} \cdot (b(1) \cdot X(z) + a(1) \cdot Y(z) + z^{-1} \cdot (\ldots + z^{-1} (b(N) \cdot X(z) + a(N) \cdot Y(z))))

 $$">
            </p>


            <p>
              For implementation, we also use the fact that the delay operator z‚Åª¬π is linear.
              This means the delay can be applied after multiplication:
            </p>
                <p class="text-lg font-mono mt-3 text-center" appMathJax="$$ z^{-1} \cdot (b(m) \cdot X(z) + a(m) \cdot Y(z)) = (b(m) \cdot X(z) + a(m) \cdot Y(z)) \cdot z^{-1}

 $$">
            </p>


            <p>
              This results in a memory-efficient FIR-IIR structure,
              which is the structure used internally by the Python function:
            </p>

            <pre>
              scipy.signal.lfilter
            </pre>

            <p>
              The corresponding signal flow diagram is shown in Figure 7.3.
            </p>
            <div class="flex flex-col justify-around items-center gap-2">
              <img src="assets/images/chap7/fig7.5.png" class="w-180 h-110 ">
            </div>



            <h3>7.2.4 IIR Filter Example</h3>

            <p>
              Returning to our simple example of an exponentially decaying signal,
              we now show how to implement it using an IIR filter.
            </p>

            <p>
              We need a system with a single pole at position <strong>p</strong>.
              This can be achieved by choosing:
            </p>

            <ul>
              <li>b(0) = 1</li>
              <li>a(1) = p</li>
            </ul>

            <p>
              This leads to the following difference equation:
            </p>
            <p class="text-lg font-mono mt-3 text-center"
                    appMathJax="$$ y(n) = 1 \cdot x(n) + p \cdot y(n - 1) \tag{7.4}

 $$">
            </p>


            <p>
              If the input signal x(n) is a unit impulse, the output becomes:
            </p>
            <p class="text-lg font-mono mt-3 text-center"
                    appMathJax="$$ 1, p, p^2, p^3, \ldots
 $$">


              <div class="flex flex-col justify-around items-center gap-2">
                <img src="assets/images/chap7/fig7.6.png" class="w-180 h-80 ">
              </div>
              <p>
                This is an infinitely long impulse response, which is why such filters
                are called Infinite Impulse Response (IIR) filters.
              </p>

              <p>
                The corresponding flow diagram of this filter is shown in Figure 7.4.
                You can compare it with the Python implementation block diagram
                shown earlier in Figure 7.3, using:
              </p>

              <ul>
                <li>b[0] = 1</li>
                <li>a[0] = 1</li>
                <li>a[1] = p</li>
              </ul>

              <p>
                Python requires the coefficient a[0] to be explicitly specified,
                and it must be equal to 1. See also:
              </p>

              <pre>
                help(lfilter)
              </pre>

              <p>
                In the z-domain, the difference equation becomes:
              </p>
              <p class="text-lg font-mono mt-3 text-center"
                    appMathJax="$$ Y(z) = X(z) + p \cdot z^{-1} \cdot Y(z)

 $$">
              </p>

              <p>
                Dividing output by input gives the transfer function:
              </p>
              <p class="text-lg font-mono mt-3 text-center"
                    appMathJax="$$ \rightarrow H(z) = \frac{Y(z)}{X(z)} = \frac{1}{1 - p \cdot z^{-1}}

 $$">
              </p>


              <p>
                This clearly reveals the feedback loop in the system.
                It is also identical to the z-transform of the exponential sequence
                derived earlier.
              </p>

              <p>
                When transformed back to the time domain, the impulse response becomes:
              </p>
              <p class="text-lg font-mono mt-3 text-center"
                    appMathJax="$$ 1, p, p^2, p^3, \ldots

 $$">
              </p>

              <p>
                This confirms that the impulse response is an exponentially decaying
                sequence.
              </p>

              <hr>

                <h3>7.2.5 Computing the Resulting Frequency Response</h3>

                <p>
                  The Python function <code>freqz</code> can be used to compute and plot
                  the magnitude and phase response of a digital filter.
                </p>

                <p>
                  Its input consists of the filter coefficients:
                </p>

                <pre>
                  freqz(b, a)
                </pre>

                <p>
                  For example, choosing p = 0.9 gives:
                </p>

                <pre class="bg-gray-100 text-sm p-3 rounded-lg overflow-x-auto font-mono mt-2">
                  from scipy.signal import freqz
                  import numpy as np
                  import matplotlib.pyplot as plt

                  a = [1, -0.9]
                  b = [1]

                  w, H = freqz(b, a)

                  plt.figure()
                  plt.subplot(2, 1, 1)
                  plt.title("Frequency Response")
                  plt.plot(w, 20 * np.log10(abs(H)))
                  plt.ylabel("Amplitude (dB)")

                  plt.subplot(2, 1, 2)
                  plt.plot(w, np.angle(H))
                  plt.ylabel("Phase (radians)")
                  plt.xlabel("Normalized Frequency")
                  plt.show()
                </pre>

                <p>
                  The resulting plot is shown in Figure 7.5.
                  The horizontal axis represents normalized frequency,
                  where the rightmost point corresponds to the Nyquist frequency.
                </p>
                <div class="flex flex-col justify-around items-center gap-2">
                  <img src="assets/images/chap7/fig7.7.png" class="w-180 h-110 ">
                </div>
                <p>
                  The magnitude response clearly shows a low-pass characteristic.
                  This simple IIR filter is often used to estimate the mean or average
                  of a signal, since the mean corresponds to the zero-frequency component.
                </p>

                <p>
                  A commonly used form of this filter is:
                </p>
                <p class="text-lg font-mono mt-3 text-center"
                    appMathJax="$$ y(n) = p \cdot y(n - 1) + (1 - p) \cdot x(n)

 $$">
                </p>


                <hr>

                  <h3>Poles and Zeros</h3>

                  <p>
                    We can visualize poles and zeros using a pole-zero plot in the complex
                    z-plane.
                  </p>
                  <p class="text-lg font-mono mt-3 text-center"
                    appMathJax="$$ H(z) = \frac{1}{1 - p \cdot z^{-1}}

 $$">
                  </p>
                  <p>
                    The pole and zero locations are computed using:
                  </p>

                  <pre class="bg-gray-100 text-sm p-3 rounded-lg overflow-x-auto font-mono mt-2">
                    np.roots(a)  // poles
                    np.roots(b)  // zeros
                  </pre>

                  <p>
                    They can be plotted using:
                  </p>

                  <pre class="bg-gray-100 text-sm p-3 rounded-lg overflow-x-auto font-mono mt-2">
                    from zplane import zplane
                    zplane(np.roots(b), np.roots(a))
                  </pre>

                  <p>
                    In the resulting plot (Figure 7.6):
                  </p>
                  <div class="flex flex-col justify-around items-center gap-2">
                    <img src="assets/images/chap7/fig7.8.png" class="w-180 h-110 ">
                  </div>
                  <ul>
                    <li>Zeros are marked with circles (o)</li>
                    <li>Poles are marked with crosses (x)</li>
                  </ul>

                  <p>
                    The pole is located at z = 0.9, which lies inside the unit circle.
                  </p>

                  <p>
                    In general:
                  </p>

                  <ul>
                    <li>The closer a pole is to the unit circle, the larger the peak in the magnitude response</li>
                    <li>The closer a zero is to the unit circle, the more the magnitude response is suppressed</li>
                  </ul>

                  <p>
                    Since the pole here lies on the positive real axis,
                    the magnitude response peaks at zero normalized frequency,
                    which matches the observed low-pass behavior.
                  </p>

                  <hr>

                    <h3>7.2.6 Python Example</h3>

                    <p>
                      The impulse response of this IIR filter can be computed using
                      <code>scipy.signal.lfilter</code>.
                    </p>

                    <pre class="bg-gray-100 text-sm p-3 rounded-lg overflow-x-auto font-mono mt-2">
                      import numpy as np
                      import scipy.signal
                      import matplotlib.pyplot as plt

                      x = np.zeros(10)
                      x[0] = 1  # unit impulse

                      A = [1, -0.9]
                      B = [1]

                      y = scipy.signal.lfilter(B, A, x)

                      plt.plot(y, '*')
                      plt.xlabel("Sample")
                      plt.ylabel("Value")
                      plt.show()
                    </pre>

                    <p>
                      The resulting plot (Figure 7.7) shows the first 10 samples of the impulse
                      response.
                    </p>

                    <div class="flex flex-col justify-around items-center gap-2">
                      <img src="assets/images/chap7/fig7.9.png" class="w-180 h-110 ">
                    </div>

                    <p>
                      As expected, the response is an exponentially decaying sequence.
                      This confirms that the filter is stable, since its pole lies inside
                      the unit circle.
                    </p>


                  </mat-card-content>

                </mat-card>
              </div>





              <!-- Test section  -->
              <div class="h-6"></div>

              <div class="flex flex-col items-center p-3 gap-6">
                <h2 class="text-2xl font-sans font-semibold mb-4">üß† Test Your Knowledge</h2>

                @for (q of questions; track q) {
                  <div class="w-full md:w-2/3">
                    <mat-card class="mat-elevation-z6 p-6 font-sans">
                      <mat-card-title>{{ q.text }}</mat-card-title>
                      <br>
                        <mat-card-content>
                          <mat-radio-group [(ngModel)]="q.selectedAnswer" [disabled]="q.isSubmitted">
                            @for (option of q.options; track option) {
                              <div class="mb-2">
                                <mat-radio-button [value]="option">{{ option }}</mat-radio-button>
                              </div>
                            }
                          </mat-radio-group>
                          <div class="mt-4 flex gap-3">
                            <button matFab extended (click)="submitAnswer(q)"
                              [disabled]="!q.selectedAnswer || q.isSubmitted">
                              Submit
                            </button>
                            @if (q.isSubmitted) {
                              <button matFab extended style="background-color:black ; color: aliceblue;"
                                (click)="tryAgain(q)">
                                Try Again
                              </button>
                            }
                          </div>
                          <div class="mt-4">
                            @if (q.isSubmitted && q.selectedAnswer === q.correctAnswer) {
                              <p
                                class="text-green-600 font-semibold font-sans">
                                ‚úÖ Correct!
                              </p>
                            }
                            @if (q.isSubmitted && q.selectedAnswer !== q.correctAnswer) {
                              <p
                                class="text-red-600 font-semibold font-sans">
                                ‚ùå Incorrect. Correct answer: <strong>{{ q.correctAnswer }}</strong>.
                              </p>
                            }
                          </div>
                        </mat-card-content>
                      </mat-card>
                    </div>
                  }
                </div>



              </div>