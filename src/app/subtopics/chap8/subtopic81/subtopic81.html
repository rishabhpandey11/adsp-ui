<div class="m-2 space-y-4">
 <div>
        <mat-card class="example-card text-2xl" appearance="outlined">
            <mat-card-header>
                <mat-card-title style="color: blue;">8.1. Theory</mat-card-title>
            </mat-card-header>

            <mat-card-content class="text-lg">
                <h1 class="mt-3 font-semibold"> 1. Filter Design</h1>
                <p class="mt-4">


                    How do we design filters, such that they have desired properties? First we should know
                    how the ideal or desired filter should look like. In general, we specify the frequency
                    responses with magnitude and phase,
                </p>


                <p class="mt-4">
                    How do we design filters so that they have the desired properties? First, we need to
                    know how the ideal or desired filter should look. In general, we specify the frequency
                    response using a magnitude term and a phase term.
                </p>

                <p class="mt-4">
                    The frequency response is written in the form:
                </p>
<p class="text-lg font-mono mt-3 text-center"
                    appMathJax="$$ H(\Omega) = e^{j\phi(\Omega)} \cdot A(\Omega)

 $$">
                </p>
             

                <p class="mt-4">
                    phi(Omega) is the phase as a function of the normalized frequency Omega, and
                    A(Omega) is the magnitude. When designing a filter, we must specify both the phase
                    and the magnitude.
                </p>

                <h3 class="mt-4 text-xl">1.1 Phase and Signal Delay</h3>

                <p class="mt-4">

                    The phase angle of a system is directly connected to the delay introduced by that system.
                    Consider a pure delay of <code>d</code> samples, which has the transfer function:
                </p>
               
                <p class="text-lg font-mono mt-3 text-center"
                    appMathJax="$$ H(z) = z^{-d}

 $$">
                </p>


                <p class="mt-4">

                    To obtain the frequency response in the Discrete Time Fourier Transform (DTFT)
                    domain, we replace <code>z</code> with <code>exp(j * Omega)</code>:
                </p>
                <p class="text-lg font-mono mt-3 text-center"
                    appMathJax="$$ He^{jΩ} = e^{-jΩ.d}

 $$">
                </p>
              

                <p class="mt-4">

                    Thus the phase response is:
                </p>
                <p class="text-lg font-mono mt-3 text-center"
                    appMathJax="$$ \phi(\Omega) = \,angle(e^{-jΩ.d}) = -\Omega \cdot d

 $$">
                </p>
               

                <p class="mt-4">

                    Conversely, we can obtain the delay in samples by dividing the phase angle by the
                    normalized frequency:
                </p>

                <p class="text-lg font-mono mt-3 text-center"
                    appMathJax="$$ d = \frac{-\,angle\left(H(e^{j\Omega})\right)}{\Omega}

 $$">
                </p>
              


                <p class="mt-4">

                    In Python, the function <code>np.angle()</code> returns the angle of a complex number in radians
                    (between 0 and 2π), matching our normalized frequency range.
                </p>

                <p class="mt-4">

                    If the phase angle is a linear function of Omega with slope <code>-d</code>, the system is said to
                    have <b>linear phase</b>. Only in this case do all frequencies experience the same delay.
                    This is crucial in applications like image processing: edges contain many frequencies,
                    and different delays across frequencies would blur the edges.
                </p>

                <p class="mt-4">

                    In general, the negative derivative of the phase with respect to Omega is called the
                    <b>group delay</b>. If the group delay is written as <code>d_g(Omega)</code>, it is defined as:
                </p>
               
                <p class="text-lg font-mono mt-3 text-center"
                    appMathJax="$$ d_g(\Omega) = \frac{-\,d\phi(\Omega)}{d\Omega}

 $$">
                </p>

                <p class="mt-4">

                    This tells us how much delay each frequency component experiences when passing
                    through the system. When designing filters, understanding and controlling this delay
                    behavior is essential.
                </p>

            </mat-card-content>
        </mat-card>
    </div>





    <div>
        <mat-card class="example-card text-2xl" appearance="outlined">

            <mat-card-content class="text-lg">
                <h3 class="text-xl font-semibold font-mono ">8.1.2 Magnitude Design</h3>

                <p class="mt-4">
                    To design a filter, we must specify the desired magnitude response A(Omega). Many filters
                    aim to have one or more pass bands, where the signal is passed with nearly 0 dB attenuation,
                    and one or more stop bands, where the signal is strongly attenuated. To achieve this, the
                    band edges must be defined in normalized frequency.
                </p>

                <p class="mt-4">
                    For an FIR filter, the filter coefficients correspond to its impulse response. The ideal impulse
                    response can be obtained from the desired frequency response H(exp(j * Omega)) using the
                    inverse DTFT:
                </p>

                <p class="text-lg font-mono mt-3 text-center"
                    appMathJax="$$ 

 $$">
                </p>
                <p class="text-center mt-3 text-lg font-mono">
                    h(n) = (1 / (2*pi)) * integral from -pi to pi of [ H(exp(j * Omega)) * exp(j * Omega * n) dOmega ]
                </p>


                <p class="mt-4">
                    This impulse response is infinitely long and extends into the past and future. Because such
                    an ideal filter cannot be realized, we must approximate the desired frequency response by
                    minimizing some error function. The choice of error function depends on the requirements
                    of the application.
                </p>

                <p class="mt-4">
                    Since real filters cannot have perfect transitions, every design must include a transition band
                    between each pass band and stop band. This band provides space for the filter to move from
                    passing the signal to rejecting it.
                </p>

                <p class="mt-4"><b>Example:</b>
                    Consider designing a half-band low-pass filter. We want the pass band from 0 to pi/2.
                    For sampling-rate conversion with a downsampling factor of 2, the stop band must begin
                    at pi/2.
                    To provide a transition, we might define the transition band from (pi/2 - 0.1) to pi/2.
                    The pass band is then from 0 to (pi/2 - 0.1).
                </p>

                <p class="mt-4">
                    This is still an idealized description because the stop band attenuation is infinite. To produce
                    a realizable filter, we define an error measure that evaluates how close the filter comes to the
                    ideal response.
                </p>

                <p class="mt-4">
                    Common error functions include:
                </p>
                <ul>
                    <li>Mean squared error</li>
                    <li>Mean absolute error</li>
                    <li>Weighted mean squared error</li>
                    <li>Minimax error (minimize the maximum deviation)</li>
                </ul>

                <p class="mt-4">
                    In a weighted mean squared error, different weights are assigned to different frequency
                    regions. Typically, the stop band is given a larger weight because errors there result in
                    poorer attenuation. For example, a weight of 1 may be used in the pass band and 1000 in
                    the stop band to encourage a much stronger stop-band attenuation.
                </p>

                <p class="mt-4">
                    The optimization usually produces equal or proportional errors across the band. For example:
                </p>

                <pre class="bg-gray-100 text-sm p-3 rounded-lg overflow-x-auto font-mono mt-2">

error_stop_band * 1000 = error_pass_band * 1

</pre>

                <p class="mt-4">
                    Thus, the stop-band error becomes the pass-band error divided by 1000.
                </p>

                <p class="mt-4">
                    For FIR linear-phase filters, Python provides the <code>remez</code> function, which implements
                    the Parks–McClellan algorithm based on the Chebyshev approximation. This algorithm
                    minimizes the maximum error in each band (with weights), producing an equiripple
                    response: all ripples have equal height in each band.
                </p>

                <p class="mt-4">
                    The function is used as:
                </p>

                <pre class="bg-gray-100 text-sm p-3 rounded-lg overflow-x-auto font-mono mt-2">

h_min = scipy.signal.remez(N, F, A, W)

</pre>
            </mat-card-content>

        </mat-card>


    </div>
    <div class="h-6"></div>
    <div>
        <mat-card class="example-card text-2xl" appearance="outlined">

            <mat-card-content class="text-lg">
                <h3 class="text-2xl font-semibold font-sans ">
                    8.1.3 Python Example
                </h3>
                <pre class="bg-gray-100 text-sm p-3 rounded-lg overflow-x-auto font-mono mt-2">

ipython --pylab
import scipy.signal as sp
N=8;
F = [0.0, 0.5/2 - 0.05, 0.5/2, 0.5]
A = [1.0, 0.0]
W = [1, 100]
hmin = sp.remez(N, F, A, weight=W)
plot(hmin)
xlabel(’Sample’)
ylabel(’Value’)

</pre>
                <div class="flex flex-col justify-around items-center gap-2">
                    <img src="assets/images/chap8/fig8.1.png" class="w-180 h-110 ">


                </div>

                <p class="mt-4">
                    Now we obtain a nice impulse response or set of coefficients hmin, which can be seen in
                    Fig. (8.1). and its frequencies response is obtained with
                </p>
                <pre class="bg-gray-100 text-sm p-3 rounded-lg overflow-x-auto font-mono mt-2">

from freqz import freqz
freqz(hmin)

</pre>
                <p class="mt-4">
                    and can be seen in Fig. (8.2).
                    Here we see that we obtain an amplitude gain of about -40 dB in the stop band, or
                    about 40 dB of stop band attenuation, which roughly corresponds to our weight of 100
                    for the stop band.

                </p>
                <p class="mt-4">
                    The phase (angle) plot has straight lines, which shows that this is a linear phase filter.
                    Observe that the angle is 2π periodic, hence this plot is not unique and has jumps. The
                    magnitude has zero crossings (where the dips go down), and at those points there are
                    sign changes, phase jumps by π, which is also why we see the jumps in the phase plot.
                </p>
            </mat-card-content>

        </mat-card>
    </div>
    <div>
        <mat-card class="example-card text-2xl" appearance="outlined">

            <mat-card-content class="text-lg">
                <h3 class="text-2xl font-semibold font-sans " style="color: blue;">
                    8.1.4 Example with Sound
                </h3>


                <p class="mt-4">
                    We have 8000 Hz sampling rate, and want to build a band pass filter. Our low stop
                    band is between 0 and 0.05, our pass band between 0.1 and 0.2, and high stop band
                    between 0.3 and 0.5 (again with 0.5 as Nyquist frequency and 1 as sampling frequency).

                    ![Screenshot 2025-11-18
                    172759.png](attachment:4f97c1b9-24f9-4ed5-9055-9758ff82b183:Screenshot_2025-11-18_172759.png)

                    Hence, our pass band will be between 0.1*8000=800Hz and 0.2*8000=1600 Hz. Hence
                    our vector of bands is
                    F=[0.0, 0.05, 0.1, 0.2, 0.3, 0.5]
                    The vector desired contains the desired magnitude A per band. Hence here for our
                    bandpass filter it is:
                    A=[0.0, 1.0, 0.0]
                    We choose our weights to:
                    weight=[100.0, 1.0, 100.0]
                    and our numtaps N= 32.
                    Hence our design function in Python is:
                </p>
                <div class="flex flex-col justify-around items-center gap-2">
                    <img src="assets/images/chap8/fig8.2.png" class="w-180 h-110 ">


                </div>
                <pre class="bg-gray-100 text-sm p-3 rounded-lg overflow-x-auto font-mono mt-2">

python3
import numpy as np
import scipy.signal
import matplotlib.pyplot as plt
N=32
bpass=scipy.signal.remez(N, [0.0, 0.05, 0.1, 0.2, 0.3, 0.5] ,\
[0.0, 1.0, 0.0], weight=[100.0, 1.0, 100.0])
[freq, response] = scipy.signal.freqz(bpass)
plt.plot(freq, 20*np.log10(np.abs(response)+1e-6))
plt.xlabel(’Normalized Frequency (pi is Nyquist Frequency)’)
plt.ylabel(Magnitude of Frequency Response in dB)
plt.title(Magnitude of Frequency Response for our Bandbass Filter)
plt.show()

</pre>
                <p class="mt-4">
                    The resulting plot can be seen in Fig. (8.3). Observe: The equi-ripple behaviour inside each band is
                    clearly visible, and we see our pass band a little left of the center. The side
                    lobe to its right is from the transition band there.
                    Next we plot its impulse response,

                </p>


                <div class="flex flex-col justify-around items-center gap-2">
                    <img src="assets/images/chap8/fig8.3.png" class="w-180 h-110 ">


                </div>

                <pre class="bg-gray-100 text-sm p-3 rounded-lg overflow-x-auto font-mono mt-2">

plt.plot(bpass)
plt.title(’Impulse Response of our Bandpass Filter’)
plt.show()

</pre>

                <p class=" mt-3 ">which can be seen in Fig. (8.4).
                    Observe: The impulse response is symmetric around the center, because it is a linear
                    phase filter, and it still has similarity with a sinc function.
                    Now try it on life audio with our python script:</p>


                <pre class="bg-gray-100 text-sm p-3 rounded-lg overflow-x-auto font-mono mt-2">
    python pyrecplay_filterblock.py
</pre>

                <div class="flex flex-col justify-around items-center gap-2">
                    <img src="assets/images/chap8/fig8.4.png" class="w-180 h-110 ">


                </div>
                <p class=" mt-3 ">
                    Observe: Speech sounds like through a very cheap telephone, since only a small band
                    is left of it (telephone bandwidth is about 0.3 to 3.4 kHz).
                    You can compare it to the non-filtered version by commenting out the
                    "data=struct.pack(..filtered..)"
                    line.
                </p>
            </mat-card-content>

        </mat-card>
    </div>


</div>