<div class="m-2 space-y-4">
 <div>
        <mat-card class="example-card text-2xl" appearance="outlined">

            <mat-card-content class="text-lg">
                <h3 class="text-2xl font-semibold font-sans " style="color: blue;">
                    8.2 Filtering and Sampling, Multirate Noble Identities
                </h3>


                <p class="mt-4">
                    This section discusses filtering and sampling in multirate systems. The Noble Identities describe
                    when
                    filtering can be exchanged with downsampling or upsampling.
                </p>
<p class="text-lg font-mono mt-3 text-center"
                    appMathJax="$$ \downarrow N \circ H(z) = H(z^N) \circ \downarrow N \\
\uparrow N \circ H(z) = H(z^N) \circ \uparrow N \tag{8.1}

 $$">
                </p>
                <p class="mt-4">
                    The identities can be written in plain text as:
                </p>

                <p class="mt-4">
                    Downsampling by N followed by filter H(z)<br>
                    = filter H(z raised to the power N) followed by downsampling by N
                </p>

                <p class="mt-4">
                    Upsampling by N followed by filter H(z)<br>
                    = filter H(z raised to the power N) followed by upsampling by N
                </p>

                <p class="mt-4">
                    Downsampling by N means keeping every Nth sample.
                    Upsampling by N means inserting N-1 zeros between each sample.
                    The operator symbol means applying one block after another (left to right).
                </p>

                <div class="flex flex-col justify-around items-center gap-2">
                    <img src="assets/images/chap8/fig8.5.png" class="w-180 h-110 ">


                </div>
                <div class="flex flex-col justify-around items-center gap-2">
                    <img src="assets/images/chap8/fig8.6.png" class="w-180 h-110 ">


                </div>
                <p class="mt-4">
                    If we take H(z) and replace z with z raised to N, the impulse response becomes upsampled.
                    For example:
                </p>
<p class="text-lg font-mono mt-3 text-center"
                    appMathJax="$$ H(z) = 1 + z-1 路 2 + z-2 路 3

 $$">
                </p>
                 
<p class="text-lg font-mono mt-3 text-center"
                    appMathJax="$$ H(z2) = 1 + z-2 路 2 + z-4 路 3

 $$">
                </p>

                <p class="mt-4">
                    The corresponding impulse response is: </p>
                
<p class="text-lg font-mono mt-3 text-center"
                    appMathJax="$$ hu = [1, 0, 2, 0, 3]

 $$">
                </p>
              

                <p class="mt-4">
                    This happens because inserting zeros between coefficients spreads the impulse response.
                    The Noble Identities show when sampling and filtering can be swapped without changing the result,
                    which usually requires a sparse (zero-inserted) impulse response.
                </p>

                <p class="mt-4">
                    However, using H(z raised to N) normally creates N repeated frequency bands due to aliasing.
                    This makes the upsampled filter unusable by itself for most applications, unless additional
                    processing
                    is applied later.
                </p>

                <h4>Example</h4>

                <p class="mt-4">
                    Take a simple running-average FIR filter:
                </p>

                <p class="text-center mt-3 text-lg font-mono">
                    B = [1, 1]
                </p>

                <p class="mt-4">
                    And an input signal:
                </p>

                <p class="text-center mt-3 text-lg font-mono">
                    x = [1, 2, 3, 4, ...]
                </p>

                <p class="mt-4">
                    Python example:
                </p>

                <p class="text-center mt-3 text-lg font-mono">
                    x = np.arange(1, 10, dtype='float')<br>
                    N = 2
                </p>

                <p class="mt-4">
                    We can now implement the first Noble Identity block diagram, corresponding to the
                    downsampling case (the first pair, producing outputs y1 and y2).
                </p>
                <div class="flex flex-col justify-around items-center gap-2">
                    <img src="assets/images/chap8/fig8.7.png" class="w-180 h-110 ">


                </div>
                <p class="mt-4">-> First, for y1, first down sampling, then filtering, the down-sampling by a factor of
                </p>

                <pre class="bg-gray-100 text-sm p-3 rounded-lg overflow-x-auto font-mono mt-2">

N=2:
xd = x[::N]
This yields
xd=1,3,5,7,9
Then apply the filter B=[1,1],
y1 = scipy.signal.lfilter(B, 1, xd)
This yields the sum of each pair in xd:
y1= 1,4,8,12,16
-> Now first filtering, then down sampling, to implement the corresponding right-hand
side block diagram of the noble identity. Our filter is now up-sampled by N=2:
Bu = np.zeros(3)
Bu[::N] = B
This yields Bu= 1,0,1
Now filter the signal before down-sampling:
yu = scipy.signal.lfilter(Bu, 1, x)
This yields
yu= 1, 2, 4, 6, 8, 10, 12, 14, 16, 18
Now down-sample it:
y2 = yu[::N]
This yields
y2= 1,4,8,12,16
Here we can now see that they are indeed identical, y1=y2!

</pre>

            </mat-card-content>

        </mat-card>
    </div>


</div>